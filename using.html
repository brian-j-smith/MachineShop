<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Using MachineShop</title>

<script src="site_libs/header-attrs-2.7/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-sm-12 col-md-4 col-lg-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-sm-12 col-md-8 col-lg-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">MachineShop for R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="using.html">Using</a>
</li>
<li>
  <a href="reference.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Examples
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="example_info.html">Model and Metric Information</a>
    </li>
    <li>
      <a href="example_variables.html">Variable Specifications and Preprocessing</a>
    </li>
    <li>
      <a href="example_settings.html">Global Settings</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="example_ichomes.html">IC Home Prices</a>
    </li>
    <li>
      <a href="example_iris.html">Iris Flowers Species</a>
    </li>
    <li>
      <a href="example_pima.html">Pima Indians Diabetes</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/brian-j-smith/MachineShop">
    <span class="fas fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Using MachineShop</h1>

</div>


<div id="melanoma-example" class="section level1">
<h1>Melanoma Example</h1>
<p>Use of the <strong>MachineShop</strong> package is demonstrated with a survival analysis example in which the response variable is a censored time to event outcome. Since survival outcomes are a combination of numerical (time to event) and categorical (event) variables, package features for both variable types are illustrated with the example. Support for outcomes other than survival, including nominal and ordinal factors as well as numeric vectors and matrices, is also discussed.</p>
<p>Survival analysis is performed with the <code>Melanoma</code> dataset from the <strong>MASS</strong> package <span class="citation">(Andersen et al. 1993)</span>. This dataset provides survival time, in days, from disease treatment to (1) death from disease, (2) alive at study termination, or (3) death from other causes for 205 Denmark patients with malignant melanomas. Also provided are potential predictors of the survival outcomes. The analysis begins by loading required packages <strong>MachineShop</strong>, <strong>survival</strong> <span class="citation">(Therneau 2020)</span>, and <strong>MASS</strong> as well as <strong>magrittr</strong> <span class="citation">(Bache and Wickham 2014)</span> for its pipe (<code>%&gt;%</code>) operator to simplify some of the code syntax. For the analysis, a binary overall survival outcome is created by combining the two death categories (1 and 3) into one.</p>
<pre class="r"><code>## Analysis libraries and dataset
library(MachineShop)
library(survival)
library(magrittr)
data(Melanoma, package = &quot;MASS&quot;)

## Malignant melanoma analysis dataset
surv_df &lt;- within(Melanoma, status &lt;- as.numeric(status != 2))</code></pre>
<p>Descriptive summaries of the study variables are given below in Table 1, followed by a plot of estimated overall survival probabilities and 95% confidence intervals.</p>
<center>
Table 1. Variable summaries for the Melanoma survival analysis example.
</center>
<table class="table table-striped table-condensed" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
Characteristic
</th>
<th style="text-align:center;">
Value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Number of subjects
</td>
<td style="text-align:center;">
205
</td>
</tr>
<tr grouplength="1">
<td colspan="2" style="border-bottom: 1px solid;">
<strong>time</strong>
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
Median (Range)
</td>
<td style="text-align:center;">
2005 (10, 5565)
</td>
</tr>
<tr grouplength="2">
<td colspan="2" style="border-bottom: 1px solid;">
<strong>status</strong>
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
1 = Dead
</td>
<td style="text-align:center;">
71 (34.63%)
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
0 = Alive
</td>
<td style="text-align:center;">
134 (65.37%)
</td>
</tr>
<tr grouplength="2">
<td colspan="2" style="border-bottom: 1px solid;">
<strong>sex</strong>
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
1 = Male
</td>
<td style="text-align:center;">
79 (38.54%)
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
0 = Female
</td>
<td style="text-align:center;">
126 (61.46%)
</td>
</tr>
<tr grouplength="1">
<td colspan="2" style="border-bottom: 1px solid;">
<strong>age</strong>
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
Median (Range)
</td>
<td style="text-align:center;">
54 (4, 95)
</td>
</tr>
<tr grouplength="1">
<td colspan="2" style="border-bottom: 1px solid;">
<strong>year</strong>
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
Median (Range)
</td>
<td style="text-align:center;">
1970 (1962, 1977)
</td>
</tr>
<tr grouplength="1">
<td colspan="2" style="border-bottom: 1px solid;">
<strong>thickness</strong>
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
Median (Range)
</td>
<td style="text-align:center;">
1.94 (0.10, 17.42)
</td>
</tr>
<tr grouplength="2">
<td colspan="2" style="border-bottom: 1px solid;">
<strong>ulcer</strong>
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
1 = Presence
</td>
<td style="text-align:center;">
90 (43.9%)
</td>
</tr>
<tr>
<td style="text-align:left;padding-left: 2em;" indentlevel="1">
0 = Absence
</td>
<td style="text-align:center;">
115 (56.1%)
</td>
</tr>
</tbody>
</table>
<p><img src="using_files/figure-html/using_example_survfit-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>For the analyses, the dataset is split into a training set on which survival models will be fit and a test set on which predictions will be made and performance evaluated. A global formula <code>surv_fo</code> is defined to relate the predictors on the right hand side to the overall survival outcome on the left and will be used for all subsequent survival models.</p>
<pre class="r"><code>## Training and test sets
set.seed(123)
train_indices &lt;- sample(nrow(surv_df), nrow(surv_df) * 2 / 3)
surv_train &lt;- surv_df[train_indices, ]
surv_test &lt;- surv_df[-train_indices, ]

## Global formula for the analysis
surv_fo &lt;- Surv(time, status) ~ sex + age + year + thickness + ulcer</code></pre>
</div>
<div id="model-fit-and-prediction" class="section level1">
<h1>Model Fit and Prediction</h1>
<div id="model-information" class="section level2">
<h2>Model Information</h2>
<p>Model fitting requires user specification of a <strong>MachineShop</strong> compatible model. A named list of package-supplied models can be obtained interactively with the <code>modelinfo()</code> function, and includes the following components for each.</p>
<dl>
<dt><code>label</code></dt>
<dd>Character descriptor for the model.
</dd>
<dt><code>packages</code></dt>
<dd>Character vector of source packages required to use the model. These need only be installed with the <code>install.packages()</code> function or by equivalent means; but need not be loaded with, for example, the <code>library()</code> function.
</dd>
<dt><code>response_types</code></dt>
<dd>Character vector of response variable types supported by the model.
</dd>
<dt><code>arguments</code></dt>
<dd>Closure with the argument names and corresponding default values of the model function.
</dd>
<dt><code>grid</code></dt>
<dd>Logical indicating whether automatic generation of tuning parameter grids is implemented for the model.
</dd>
<dt><code>varimp</code></dt>
<dd>Logical indicating whether variable importance is defined for the model.
</dd>
</dl>
<p>Function <code>modelinfo()</code> may be called without arguments, with one or more model functions, observed response variables, or vectors representing response variable types; and will return information on all matching models.</p>
<pre class="r"><code>## All available models
modelinfo() %&gt;% names
#&gt;  [1] &quot;AdaBagModel&quot;         &quot;AdaBoostModel&quot;       &quot;BARTMachineModel&quot;   
#&gt;  [4] &quot;BARTModel&quot;           &quot;BlackBoostModel&quot;     &quot;C50Model&quot;           
#&gt;  [7] &quot;CForestModel&quot;        &quot;CoxModel&quot;            &quot;CoxStepAICModel&quot;    
#&gt; [10] &quot;EarthModel&quot;          &quot;FDAModel&quot;            &quot;GAMBoostModel&quot;      
#&gt; [13] &quot;GBMModel&quot;            &quot;GLMBoostModel&quot;       &quot;GLMModel&quot;           
#&gt; [16] &quot;GLMStepAICModel&quot;     &quot;GLMNetModel&quot;         &quot;KNNModel&quot;           
#&gt; [19] &quot;LARSModel&quot;           &quot;LDAModel&quot;            &quot;LMModel&quot;            
#&gt; [22] &quot;MDAModel&quot;            &quot;NaiveBayesModel&quot;     &quot;NNetModel&quot;          
#&gt; [25] &quot;PDAModel&quot;            &quot;PLSModel&quot;            &quot;POLRModel&quot;          
#&gt; [28] &quot;QDAModel&quot;            &quot;RandomForestModel&quot;   &quot;RangerModel&quot;        
#&gt; [31] &quot;RFSRCModel&quot;          &quot;RPartModel&quot;          &quot;SelectedModel&quot;      
#&gt; [34] &quot;StackedModel&quot;        &quot;SuperModel&quot;          &quot;SurvRegModel&quot;       
#&gt; [37] &quot;SurvRegStepAICModel&quot; &quot;SVMModel&quot;            &quot;SVMANOVAModel&quot;      
#&gt; [40] &quot;SVMBesselModel&quot;      &quot;SVMLaplaceModel&quot;     &quot;SVMLinearModel&quot;     
#&gt; [43] &quot;SVMPolyModel&quot;        &quot;SVMRadialModel&quot;      &quot;SVMSplineModel&quot;     
#&gt; [46] &quot;SVMTanhModel&quot;        &quot;TreeModel&quot;           &quot;TunedModel&quot;         
#&gt; [49] &quot;XGBModel&quot;            &quot;XGBDARTModel&quot;        &quot;XGBLinearModel&quot;     
#&gt; [52] &quot;XGBTreeModel&quot;</code></pre>
<p>Information is displayed below for the <code>GBMModel()</code> function corresponding to a generalized boosted regression model, which is applicable to survival outcomes.</p>
<pre class="r"><code>## Model-specific information
modelinfo(GBMModel)
#&gt; $GBMModel
#&gt; $GBMModel$label
#&gt; [1] &quot;Generalized Boosted Regression&quot;
#&gt; 
#&gt; $GBMModel$packages
#&gt; [1] &quot;gbm&quot;
#&gt; 
#&gt; $GBMModel$response_types
#&gt; [1] &quot;factor&quot;         &quot;numeric&quot;        &quot;PoissonVariate&quot; &quot;Surv&quot;          
#&gt; 
#&gt; $GBMModel$arguments
#&gt; function (distribution = NULL, n.trees = 100, interaction.depth = 1, 
#&gt;     n.minobsinnode = 10, shrinkage = 0.1, bag.fraction = 0.5) 
#&gt; NULL
#&gt; 
#&gt; $GBMModel$grid
#&gt; [1] TRUE
#&gt; 
#&gt; $GBMModel$varimp
#&gt; [1] TRUE</code></pre>
<p>Submitting the model function at the console will result in similar information being displayed as formatted text.</p>
<pre class="r"><code>GBMModel
#&gt; Object of class &quot;MLModelFunction&quot;
#&gt; 
#&gt; Model name: GBMModel
#&gt; Label: Generalized Boosted Regression
#&gt; Package: gbm
#&gt; Response types: factor, numeric, PoissonVariate, Surv
#&gt; Tuning grid: TRUE
#&gt; Variable importance: TRUE
#&gt; 
#&gt; Arguments:
#&gt; function (distribution = NULL, n.trees = 100, interaction.depth = 1, 
#&gt;     n.minobsinnode = 10, shrinkage = 0.1, bag.fraction = 0.5) 
#&gt; NULL</code></pre>
<div id="type-specific-models" class="section level3">
<h3>Type-Specific Models</h3>
<p>When data objects are supplied as arguments to <code>modelinfo()</code>, information is returned on all models applicable to response variables of the same data types. If model functions are additionally supplied as arguments, information on the subset matching the data types is returned.</p>
<pre class="r"><code>## All survival response-specific models
modelinfo(Surv(0)) %&gt;% names
#&gt;  [1] &quot;BARTModel&quot;           &quot;BlackBoostModel&quot;     &quot;CForestModel&quot;       
#&gt;  [4] &quot;CoxModel&quot;            &quot;CoxStepAICModel&quot;     &quot;GAMBoostModel&quot;      
#&gt;  [7] &quot;GBMModel&quot;            &quot;GLMBoostModel&quot;       &quot;GLMNetModel&quot;        
#&gt; [10] &quot;RangerModel&quot;         &quot;RFSRCModel&quot;          &quot;RPartModel&quot;         
#&gt; [13] &quot;SelectedModel&quot;       &quot;StackedModel&quot;        &quot;SuperModel&quot;         
#&gt; [16] &quot;SurvRegModel&quot;        &quot;SurvRegStepAICModel&quot; &quot;TunedModel&quot;         
#&gt; [19] &quot;XGBModel&quot;            &quot;XGBDARTModel&quot;        &quot;XGBLinearModel&quot;     
#&gt; [22] &quot;XGBTreeModel&quot;

## Identify survival response-specific models
modelinfo(Surv(0), CoxModel, GBMModel, SVMModel) %&gt;% names
#&gt; [1] &quot;CoxModel&quot; &quot;GBMModel&quot;</code></pre>
</div>
<div id="response-variable-specific-models" class="section level3">
<h3>Response Variable-Specific Models</h3>
<p>As a special case of type-specific arguments, existing response variables to be used in analyses may be given as arguments to identify applicable models.</p>
<pre class="r"><code>## Models for a responses variable
modelinfo(Surv(surv_df$time, surv_df$status)) %&gt;% names
#&gt;  [1] &quot;BARTModel&quot;           &quot;BlackBoostModel&quot;     &quot;CForestModel&quot;       
#&gt;  [4] &quot;CoxModel&quot;            &quot;CoxStepAICModel&quot;     &quot;GAMBoostModel&quot;      
#&gt;  [7] &quot;GBMModel&quot;            &quot;GLMBoostModel&quot;       &quot;GLMNetModel&quot;        
#&gt; [10] &quot;RangerModel&quot;         &quot;RFSRCModel&quot;          &quot;RPartModel&quot;         
#&gt; [13] &quot;SelectedModel&quot;       &quot;StackedModel&quot;        &quot;SuperModel&quot;         
#&gt; [16] &quot;SurvRegModel&quot;        &quot;SurvRegStepAICModel&quot; &quot;TunedModel&quot;         
#&gt; [19] &quot;XGBModel&quot;            &quot;XGBDARTModel&quot;        &quot;XGBLinearModel&quot;     
#&gt; [22] &quot;XGBTreeModel&quot;</code></pre>
</div>
</div>
<div id="fit-function" class="section level2">
<h2>Fit Function</h2>
<p>Package models, such as <code>GBMModel</code>, can be specified in the <code>model</code> argument of the <code>fit()</code> function to estimate a relationship (<code>surv_fo</code>) between predictors and an outcome based on a set of data (<code>surv_train</code>). Argument specifications may be in terms of the model function, function name, or a function call.</p>
<pre class="r"><code>## Generalized boosted regression fit

## Model function
surv_fit &lt;- fit(surv_fo, data = surv_train, model = GBMModel)

## Model function name
fit(surv_fo, data = surv_train, model = &quot;GBMModel&quot;)

## Model function call
fit(surv_fo, data = surv_train, model = GBMModel(n.trees = 100, interaction.depth = 1))</code></pre>
<p>Model function arguments will assume their default values unless otherwise changed in a function call.</p>
</div>
<div id="dynamic-model-parameters" class="section level2">
<h2>Dynamic Model Parameters</h2>
<p><em>Dynamic model parameters</em> are model function arguments defined as expressions to be evaluated at the time of model fitting. As such, their values can change based on characteristics of the analytic dataset, including the number of observations or predictor variables. Expressions to dynamic parameters are specified within the package-supplied quote operator <code>.()</code> and can include the following objects:</p>
<dl>
<dt><code>nobs</code></dt>
<dd>number of observations in <code>data</code>.
</dd>
<dt><code>nvars</code></dt>
<dd>number of predictor variables in <code>data</code>.
</dd>
<dt><code>y</code></dt>
<dd>response variable.
</dd>
</dl>
<p>In the example below, Bayesian information criterion (BIC) based stepwise variable selection is performed by creating a <code>CoxStepAICModel</code> with dynamic parameter <code>k</code> to be calculated as the log number of observations in the fitted dataset.</p>
<pre class="r"><code>## Dynamic model parameter k = log number of observations

## Number of observations: nobs
fit(surv_fo, data = surv_train, model = CoxStepAICModel(k = .(log(nobs))))

## Response variable: y
fit(surv_fo, data = surv_train, model = CoxStepAICModel(k = .(log(length(y)))))</code></pre>
</div>
<div id="predict-function" class="section level2">
<h2>Predict Function</h2>
<p>A <code>predict()</code> function is supplied for application to model fit results to obtain predicted values on a dataset specified with its <code>newdata</code> argument or on the original dataset if not specified. Survival means are predicted for survival outcomes by default. Estimates of the associated survival distributions are needed to calculate the means. For models, like <code>GBMModel</code>, that perform semi- or non-parametric survival analysis, Weibull approximations to the survival distributions are the default for mean estimation. Other choices of distributional approximations are exponential, Rayleigh, and empirical. Empirical distributions are applicable to Cox proportional hazards-based models and can be calculated with the method of Breslow <span class="citation">(1972)</span>, Efron <span class="citation">(1977, default)</span>, or Fleming and Harrington <span class="citation">(1984)</span>. Note, however, that empirical survival means are undefined mathematically if an event does not occur at the longest follow-up time. In such situations, a restricted survival mean is calculated by changing the longest follow-up time to an event, as suggested by Efron <span class="citation">(1967)</span>, which will be negatively biased.</p>
<pre class="r"><code>## Predicted survival means (default: Weibull distribution)
predict(surv_fit, newdata = surv_test) %&gt;% head
#&gt; [1]   776.3621  6568.9623 16476.4377  1301.2555  1650.2195  8737.8829

## Predicted survival means (empirical distribution)
predict(surv_fit, newdata = surv_test, dist = &quot;empirical&quot;) %&gt;% head
#&gt; [1] 1059.962 4694.756 5273.094 1865.118 2351.706 4939.165</code></pre>
<p>In addition to survival means, predicted survival probabilities (<code>type = "prob"</code>) or 0-1 survival events (default: <code>type = "response"</code>) can be obtained with the follow-up <code>times</code> argument. The cutoff probability for classification of survival events (or other binary responses) can be set optionally with the <code>cutoff</code> argument (default: <code>cutoff = 0.5</code>). As with mean estimation, distributional approximations to the survival functions may be specified for the predictions, with the default for survival probabilities being the empirical distribution.</p>
<pre class="r"><code>## Predict survival probabilities and events at specified follow-up times
surv_times &lt;- 365 * c(5, 10)

predict(surv_fit, newdata = surv_test, times = surv_times, type = &quot;prob&quot;) %&gt;% head
#&gt; Object of class &quot;SurvProbs&quot;
#&gt;         Time 1     Time 2
#&gt; [1,] 0.1211066 0.02533558
#&gt; [2,] 0.8684308 0.78222860
#&gt; [3,] 0.9569571 0.92625908
#&gt; [4,] 0.3337804 0.14801706
#&gt; [5,] 0.4439461 0.24320762
#&gt; [6,] 0.9064022 0.84273837
#&gt; Times:
#&gt; [1] 1825 3650

predict(surv_fit, newdata = surv_test, times = surv_times, cutoff = 0.7) %&gt;% head
#&gt; Object of class &quot;SurvEvents&quot;
#&gt;      Time 1 Time 2
#&gt; [1,]      1      1
#&gt; [2,]      0      0
#&gt; [3,]      0      0
#&gt; [4,]      1      1
#&gt; [5,]      1      1
#&gt; [6,]      0      0
#&gt; Times:
#&gt; [1] 1825 3650</code></pre>
<p>Prediction of other outcome types is more straightforward. Predicted numeric and factor responses are of the same class as the observed values at the default <code>type = "response"</code>; whereas, double (decimal) numeric values and factor level probabilities result when <code>type = "prob"</code>.</p>
</div>
</div>
<div id="variable-specifications" class="section level1">
<h1>Variable Specifications</h1>
<p>Variable specification defines the relationship between response and predictor variables as well as the data used to estimate the relationship. Four main types of specifications are supported by the package’s <code>fit()</code> and <code>resample()</code> functions: traditional formula, design matrix, model frame, and recipe.</p>
<div id="traditional-formula" class="section level2">
<h2>Traditional Formula</h2>
<p>Variables may be specified with a traditional formula and data frame pair, as was done at the start of the survival example. This specification allows for crossing (<code>*</code>), interaction (<code>:</code>), and removal (<code>-</code>) of predictors in the formula; <code>.</code> substitution of variables not already appearing in the formula; in-line functions of response variables; and in-lining of operators and functions of predictors.</p>
<pre class="r"><code>## Datasets
data(Pima.te, package = &quot;MASS&quot;)
data(Pima.tr, package = &quot;MASS&quot;)

## Formula specification
model_fit &lt;- fit(type ~ ., data = Pima.tr, model = GBMModel)
predict(model_fit, newdata = Pima.te) %&gt;% head
#&gt; [1] Yes No  No  No  Yes Yes
#&gt; Levels: No Yes</code></pre>
<p>The syntax for traditional formulas is detailed in the <strong>R</strong> help documentation on the <code>formula()</code> function. However, some constraints are placed on the syntax by the <strong>MachineShop</strong> package. Specifically, in-lining on the right-hand side of formulas is limited to the operators and functions listed in the <code>"RHS.formula"</code> package setting.</p>
<pre class="r"><code>settings(&quot;RHS.formula&quot;)
#&gt;  [1] &quot;!&quot;        &quot;!=&quot;       &quot;%%&quot;       &quot;%/%&quot;      &quot;%in%&quot;     &quot;&amp;&quot;       
#&gt;  [7] &quot;(&quot;        &quot;*&quot;        &quot;+&quot;        &quot;-&quot;        &quot;.&quot;        &quot;/&quot;       
#&gt; [13] &quot;:&quot;        &quot;&lt;&quot;        &quot;&lt;=&quot;       &quot;==&quot;       &quot;&gt;&quot;        &quot;&gt;=&quot;      
#&gt; [19] &quot;I&quot;        &quot;^&quot;        &quot;abs&quot;      &quot;acos&quot;     &quot;acosh&quot;    &quot;asin&quot;    
#&gt; [25] &quot;asinh&quot;    &quot;atan&quot;     &quot;atanh&quot;    &quot;ceiling&quot;  &quot;cos&quot;      &quot;cosh&quot;    
#&gt; [31] &quot;cospi&quot;    &quot;digamma&quot;  &quot;exp&quot;      &quot;expm1&quot;    &quot;floor&quot;    &quot;gamma&quot;   
#&gt; [37] &quot;lgamma&quot;   &quot;log&quot;      &quot;log1p&quot;    &quot;offset&quot;   &quot;round&quot;    &quot;sign&quot;    
#&gt; [43] &quot;signif&quot;   &quot;sin&quot;      &quot;sinh&quot;     &quot;sinpi&quot;    &quot;sqrt&quot;     &quot;tan&quot;     
#&gt; [49] &quot;tanh&quot;     &quot;tanpi&quot;    &quot;trigamma&quot; &quot;trunc&quot;    &quot;|&quot;</code></pre>
<p>This setting is intended to help avoid the definition of predictor variable encodings that involve dataset-specific parameter calculations. Such parameters would be calculated separated on training and test sets, and could lead to failed calculations or improper estimates of predictive performance. For example, the <code>factor()</code> function is not allowed because consistency of its (default) encoding requires that all levels be present in every dataset. Resampled datasets subset the original cases and are thus prone to missing factor levels. For users wishing to apply factor encodings or other encodings not available with traditional formulas, a more flexible preprocessing recipe syntax is supported, as described later.</p>
</div>
<div id="design-matrix" class="section level2">
<h2>Design Matrix</h2>
<p>Variables stored separately in a design matrix of predictors and object of responses can be supplied to the fit functions directly. Fitting with design matrices has less computational overhead than traditional formulas and allows for greater numbers of predictor variables in some models, including <code>GBMModel</code>, <code>GLMNetModel</code>, and <code>RandomForestModel</code>.</p>
<pre class="r"><code>## Example design matrix and response object
x &lt;- model.matrix(type ~ . - 1, data = Pima.tr)
y &lt;- Pima.tr$type

## Design matrix specification
model_fit &lt;- fit(x, y, model = GBMModel)
predict(model_fit, newdata = Pima.te) %&gt;% head
#&gt; [1] Yes No  No  No  Yes Yes
#&gt; Levels: No Yes</code></pre>
</div>
<div id="model-frame" class="section level2">
<h2>Model Frame</h2>
<p>A <code>ModelFrame</code> class is defined by the package for specification of predictor and response variables along with other attributes to control model fitting. Model frames can be created with calls to the <code>ModelFrame()</code> constructor function using a syntax similar to the traditional formula or design matrix.</p>
<pre class="r"><code>## Model frame specification

## Formula
mf &lt;- ModelFrame(type ~ ., data = Pima.tr)
model_fit &lt;- fit(mf, model = GBMModel)
predict(model_fit, newdata = Pima.te) %&gt;% head
#&gt; [1] Yes No  No  No  Yes Yes
#&gt; Levels: No Yes

## Design matrix
mf &lt;- ModelFrame(x, y)
model_fit &lt;- fit(mf, model = GBMModel)
predict(model_fit, newdata = Pima.te) %&gt;% head
#&gt; [1] Yes No  No  No  No  Yes
#&gt; Levels: No Yes</code></pre>
<p>The model frame approach has a few advantages over model fitting directly with a traditional formula. One is that cases with missing values on any of the response or predictor variables are excluded from the model frame by default. This is often desirable for models that do not handle missing values. Conversely, missing values can be retained in the model frame by setting its argument <code>na.rm = FALSE</code> for models, like <code>GBMModel</code>, that do handle them. A second advantage is that case weights can be included in the model frame to be passed on to the model fitting functions.</p>
<pre class="r"><code>## Model frame specification with case weights
mf &lt;- ModelFrame(ncases / (ncases + ncontrols) ~ agegp + tobgp + alcgp, data = esoph,
                 weights = with(esoph, ncases + ncontrols))
fit(mf, model = GBMModel)</code></pre>
<p>A third, which will be illustrated later, is user-specification of a variable for stratified resampling via the constructor’s <code>strata</code> argument.</p>
</div>
<div id="preprocessing-recipe" class="section level2">
<h2>Preprocessing Recipe</h2>
<p>The <strong>recipes</strong> package <span class="citation">(Kuhn and Wickham 2020)</span> provides a flexible framework for defining predictor and response variables as well as preprocessing steps to be applied to them prior to model fitting. Using recipes helps ensure that estimation of predictive performance accounts for all modeling step. They are also a convenient way of consistently applying preprocessing to new data. A basic recipe is given below in terms of the formula and data frame ingredients needed for the analysis.</p>
<pre class="r"><code>## Recipe specification
library(recipes)

rec &lt;- recipe(type ~ ., data = Pima.tr)
model_fit &lt;- fit(rec, model = GBMModel)
predict(model_fit, newdata = Pima.te) %&gt;% head
#&gt; [1] Yes No  No  No  No  Yes
#&gt; Levels: No Yes</code></pre>
<p>As shown, prediction on new data with a model fit to a recipe is done on an unprocessed dataset. Recipe case weights and stratified resampling are supported with the <code>role_case()</code> function. As an example, an initial step is included in the recipe below to replace the original role of variable <code>weights</code> with a designation of case weights. That is followed by a step to convert three ordinal factors to integer scores.</p>
<pre class="r"><code>## Recipe specification with case weights
df &lt;- within(esoph, {
  y &lt;- ncases / (ncases + ncontrols)
  weights &lt;- ncases + ncontrols
})

rec &lt;- recipe(y ~ agegp + tobgp + alcgp + weights, data = df) %&gt;%
  role_case(weight = weights, replace = TRUE) %&gt;%
  step_ordinalscore(agegp, tobgp, alcgp)
fit(rec, model = GBMModel)</code></pre>
</div>
<div id="summary" class="section level2">
<h2>Summary</h2>
<p>The variable specification approaches differ with respect to support for preprocessing, in-line functions, case weights, resampling strata, and computational overhead, as summarized in the table below. Only recipes apply preprocessing steps automatically during model fitting and should be used when it is important to account for such steps in the estimation of model predictive performance. Preprocessing would need to be done manually and separately otherwise. Design matrices have the lowest computational overhead and can enable analyses involving larger numbers of predictors than the other approaches. Both recipes and model frames allow for user-defined case weights (default: equal) and resampling strata (default: none). The remaining approaches are fixed to have equal weights and strata defined by the response variable. Syntax ranges from simplest to most complex for design matrices, traditional formulas, model frames, and recipes, respectively. The relative strengths of each approach should be considered within the context of a given analysis when deciding upon which one to use.</p>
<table class="table table-striped table-condensed" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
Table 2. Characteristics of available variable specification approaches.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Specification
</th>
<th style="text-align:center;">
Preprocessing
</th>
<th style="text-align:center;">
In-line Functions
</th>
<th style="text-align:center;">
Case Weights
</th>
<th style="text-align:center;">
Resampling Strata
</th>
<th style="text-align:center;">
Computational Overhead
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;font-weight: bold;">
Traditional Formula
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">manual</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">yes</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">equal</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">response</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: blue !important;">medium</span>
</td>
</tr>
<tr>
<td style="text-align:left;font-weight: bold;">
Design Matrix
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">manual</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">no</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">equal</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">response</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">low</span>
</td>
</tr>
<tr grouplength="2">
<td colspan="6" style="border-bottom: 1px solid;">
<strong>Model Frame</strong>
</td>
</tr>
<tr>
<td style="text-align:left;font-weight: bold;padding-left: 2em;" indentlevel="1">
Traditional Formula
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">manual</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">yes</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">user</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">user</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: blue !important;">medium</span>
</td>
</tr>
<tr>
<td style="text-align:left;font-weight: bold;padding-left: 2em;" indentlevel="1">
Design Matrix
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">manual</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">no</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">user</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">user</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">low</span>
</td>
</tr>
<tr>
<td style="text-align:left;font-weight: bold;">
Recipe
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">automatic</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">no</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">user</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: green !important;">user</span>
</td>
<td style="text-align:center;">
<span style="     color: white !important;border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: orange !important;">high</span>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="response-variable-types" class="section level1">
<h1>Response Variable Types</h1>
<p>The <strong>R</strong> class types of response variables play a central role in their analysis with the package. They determine, for example, the specific models that can be fit, fitting algorithms employed, predicted values produced, and applicable performance metrics and analyses. As described in the following sections, factors, ordered factors, numeric vectors and matrices, and survival objects are supported by the package.</p>
<div id="factor" class="section level2">
<h2>Factor</h2>
<p>Categorical responses with two or more levels should be coded as a <code>factor</code> variable for analysis. Prediction is of factor levels by default and of level-specific probabilities if <code>type = "prob"</code>.</p>
<pre class="r"><code>## Iris flowers species (3-level factor)
model_fit &lt;- fit(Species ~ ., data = iris, model = GBMModel)
predict(model_fit) %&gt;% head
#&gt; [1] setosa setosa setosa setosa setosa setosa
#&gt; Levels: setosa versicolor virginica
predict(model_fit, type = &quot;prob&quot;) %&gt;% head
#&gt;         setosa   versicolor    virginica
#&gt; [1,] 0.9999236 7.632570e-05 6.077426e-08
#&gt; [2,] 0.9999825 1.716847e-05 3.722919e-07
#&gt; [3,] 0.9999713 2.851341e-05 1.663462e-07
#&gt; [4,] 0.9999755 2.425451e-05 1.969964e-07
#&gt; [5,] 0.9999236 7.632570e-05 6.077426e-08
#&gt; [6,] 0.9999236 7.632570e-05 6.077426e-08</code></pre>
<p>In the case of a binary factor, the second factor level is treated as the event and the level for which predicted probabilities are computed.</p>
<pre class="r"><code>## Pima Indians diabetes statuses (binary factor)
data(Pima.te, package = &quot;MASS&quot;)
data(Pima.tr, package = &quot;MASS&quot;)

model_fit &lt;- fit(type ~ ., data = Pima.tr, model = GBMModel)
predict(model_fit, newdata = Pima.te) %&gt;% head
#&gt; [1] Yes No  No  No  Yes Yes
#&gt; Levels: No Yes
predict(model_fit, newdata = Pima.te, type = &quot;prob&quot;) %&gt;% head
#&gt; [1] 0.90724668 0.07228020 0.01806732 0.03284889 0.62654894 0.82684946</code></pre>
</div>
<div id="ordered-factor" class="section level2">
<h2>Ordered Factor</h2>
<p>Categorical responses can be designated as having ordered levels by storing them as an <code>ordered</code> factor variable. For categorical vectors, this can be accomplished with the <code>factor()</code> function and its argument <code>ordered = TRUE</code> or more simply with the <code>ordered()</code> function. Numeric vectors can be converted to ordered factors with the <code>cut()</code> function.</p>
<pre class="r"><code>## Iowa City housing prices (ordered factor)
df &lt;- within(ICHomes,
  sale_amount &lt;- cut(sale_amount, breaks = 3,
                     labels = c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;),
                     ordered_result = TRUE)
)

model_fit &lt;- fit(sale_amount ~ ., data = df, model = GBMModel)
predict(model_fit) %&gt;% head
#&gt; [1] Low Low Low Low Low Low
#&gt; Levels: Low &lt; Medium &lt; High
predict(model_fit, type = &quot;prob&quot;) %&gt;% head
#&gt;            Low      Medium         High
#&gt; [1,] 0.9974132 0.002554372 3.240887e-05
#&gt; [2,] 0.9974023 0.002572455 2.527048e-05
#&gt; [3,] 0.9791038 0.020831702 6.446588e-05
#&gt; [4,] 0.9540882 0.045822941 8.885475e-05
#&gt; [5,] 0.9115048 0.088383703 1.114675e-04
#&gt; [6,] 0.9341394 0.065776477 8.416416e-05</code></pre>
</div>
<div id="numeric-vector" class="section level2">
<h2>Numeric Vector</h2>
<p>Code univariate numerical responses as a <code>numeric</code> variable. Predicted numeric values are of the original storage mode (integer or double) by default, and doubles if <code>type = "prob"</code>.</p>
<pre class="r"><code>## Iowa City housing prices
model_fit &lt;- fit(sale_amount ~ ., data = ICHomes, model = GBMModel)
predict(model_fit) %&gt;% head
#&gt; [1] 107132 165636 210175 133135 229971 235009
predict(model_fit, type = &quot;prob&quot;) %&gt;% head
#&gt; [1] 107132.0 165636.5 210175.3 133134.6 229971.0 235009.2</code></pre>
</div>
<div id="numeric-matrix" class="section level2">
<h2>Numeric Matrix</h2>
<p>Store multivariate numerical responses as a numeric <code>matrix</code> variable for model fitting with traditional formulas and model frames.</p>
<pre class="r"><code>## Anscombe&#39;s multiple regression models dataset

## Numeric matrix response formula
model_fit &lt;- fit(cbind(y1, y2, y3) ~ x1, data = anscombe, model = LMModel)
predict(model_fit) %&gt;% head
#&gt;             y1        y2       y3
#&gt; [1,]  8.001000  8.000909 7.999727
#&gt; [2,]  7.000818  7.000909 7.000273
#&gt; [3,]  9.501273  9.500909 9.498909
#&gt; [4,]  7.500909  7.500909 7.500000
#&gt; [5,]  8.501091  8.500909 8.499455
#&gt; [6,] 10.001364 10.000909 9.998636</code></pre>
<p>For recipes, the multiple response may be defined as a single variable in a data frame or on the left hand side of a recipe formula.</p>
<pre class="r"><code>## Numeric matrix response recipe
## Defined in a data frame
df &lt;- within(anscombe, y &lt;- cbind(y1, y2, y3))
rec &lt;- recipe(y ~ x1, data = df)

## Defined in a recipe formula
rec &lt;- recipe(y1 + y2 + y3 ~ x1, data = anscombe)
model_fit &lt;- fit(rec, model = LMModel)
predict(model_fit) %&gt;% head
#&gt;             y1        y2       y3
#&gt; [1,]  8.001000  8.000909 7.999727
#&gt; [2,]  7.000818  7.000909 7.000273
#&gt; [3,]  9.501273  9.500909 9.498909
#&gt; [4,]  7.500909  7.500909 7.500000
#&gt; [5,]  8.501091  8.500909 8.499455
#&gt; [6,] 10.001364 10.000909 9.998636</code></pre>
</div>
<div id="survival-objects" class="section level2">
<h2>Survival Objects</h2>
<p>Censored time-to-event survival responses should be stored as a <code>Surv</code> variable for model fitting with traditional formulas and model frames.</p>
<pre class="r"><code>## Survival response formula
library(survival)

fit(Surv(time, status) ~ ., data = surv_train, model = GBMModel)</code></pre>
<p>For recipes, survival responses may be defined as a single <code>Surv</code> variable in a data frame or with the individual survival time and event variables given on the left hand side of a recipe formula and their roles designated with the <code>role_surv()</code> function.</p>
<pre class="r"><code>## Survival response recipe
## Defined in a data frame
df &lt;- within(veteran, {
  y &lt;- Surv(time, status)
  remove(time, status)
})
rec &lt;- recipe(y ~ ., data = df)

## Defined in a recipe formula
rec &lt;- recipe(time + status ~ ., data = veteran) %&gt;%
  role_surv(time = time, event = status)
fit(rec, model = GBMModel)</code></pre>
</div>
</div>
<div id="model-performance-metrics" class="section level1">
<h1>Model Performance Metrics</h1>
<p>Performance metrics quantify associations between observed and predicted responses and provide a means of evaluating the predictive performances of models.</p>
<div id="performance-function" class="section level2">
<h2>Performance Function</h2>
<p>Metrics can be computed with the <code>performance()</code> function applied to observed responses and responses predicted with the <code>predict()</code> function. In the case of observed versus predicted survival probabilities or events, metrics will be calculated at user-specified survival times and returned along with their time-integrated mean.</p>
<pre class="r"><code>## Survival performance metrics

## Observed responses
obs &lt;- response(surv_fit, newdata = surv_test)

## Predicted survival means
pred_means &lt;- predict(surv_fit, newdata = surv_test)
performance(obs, pred_means)
#&gt;   C-Index 
#&gt; 0.6127013

## Predicted survival probabilities
pred_probs &lt;- predict(surv_fit, newdata = surv_test, times = surv_times, type = &quot;prob&quot;)
performance(obs, pred_probs)
#&gt;     Brier.mean    Brier.time1    Brier.time2   ROC AUC.mean  ROC AUC.time1 
#&gt;      0.2700376      0.2265776      0.3134975      0.5885859      0.5972516 
#&gt;  ROC AUC.time2  Accuracy.mean Accuracy.time1 Accuracy.time2 
#&gt;      0.5799203      0.6312072      0.7354396      0.5269749

## Predicted survival events
pred_events &lt;- predict(surv_fit, newdata = surv_test, times = surv_times)
performance(obs, pred_events)
#&gt;  Accuracy.mean Accuracy.time1 Accuracy.time2 
#&gt;      0.6312072      0.7354396      0.5269749</code></pre>
<p>Function <code>performance()</code> computes a default set of metrics according to the observed and predicted response types, as indicated and in the order given in the table below.</p>
<p>Table 3. Default performance metrics by response types.</p>
<table>
<colgroup>
<col width="30%" />
<col width="69%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Response</th>
<th align="left">Default Metrics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Factor</td>
<td align="left">Brier Score, Accuracy, Cohen’s Kappa</td>
</tr>
<tr class="even">
<td align="left">Binary Factor</td>
<td align="left">Brier Score, Accuracy, Cohen’s Kappa, Area Under ROC Curve, Sensitivity, Specificity</td>
</tr>
<tr class="odd">
<td align="left">Numeric Vector or Matrix</td>
<td align="left">Root Mean Squared Error, R<sup>2</sup>, Mean Absolute Error</td>
</tr>
<tr class="even">
<td align="left">Survival Means</td>
<td align="left">Concordance Index</td>
</tr>
<tr class="odd">
<td align="left">Survival Probabilities</td>
<td align="left">Brier Score, Area Under ROC Curve, Accuracy</td>
</tr>
<tr class="even">
<td align="left">Survival Events</td>
<td align="left">Accuracy</td>
</tr>
</tbody>
</table>
<p>These defaults may be changed by specifying one or more package-supplied metric functions to the <code>metrics</code> argument of <code>performance()</code>. Specification of the <code>metrics</code> argument can be in terms of a single metric function, function name, or list of metric functions. List names, if specified, will be displayed as metric labels in graphical and tabular summaries; otherwise, the function names will be used as labels for unnamed lists.</p>
<pre class="r"><code>## Single metric function
performance(obs, pred_means, metrics = cindex)

## Single metric function name
performance(obs, pred_means, metrics = &quot;cindex&quot;)

## List of metric functions
performance(obs, pred_means, metrics = c(cindex, rmse, rmsle))

## Named list of metric functions
performance(obs, pred_means, metrics = c(&quot;CIndex&quot; = cindex,
                                         &quot;RMSE&quot; = rmse,
                                         &quot;RMSLE&quot; = rmsle))</code></pre>
<p>Metrics based on classification of two-level class probabilities, like sensitivity and specificity, optionally allow for specification of the classification cutoff probability (default: <code>cutoff = 0.5</code>).</p>
<pre class="r"><code>## User-specified survival probability metrics
performance(obs, pred_probs, metrics = c(sensitivity, specificity), cutoff = 0.7)
#&gt;  sensitivity.mean sensitivity.time1 sensitivity.time2  specificity.mean 
#&gt;         0.5075277         0.4637997         0.5512557         0.7207524 
#&gt; specificity.time1 specificity.time2 
#&gt;         0.7681212         0.6733836</code></pre>
</div>
<div id="metric-functions" class="section level2">
<h2>Metric Functions</h2>
<p>Whereas multiple package-supplied metrics can be calculated simultaneously with the <code>performance()</code> function, each exists as a stand-alone function that can be called individually.</p>
<pre class="r"><code>## Metric functions for survival means
cindex(obs, pred_means)
#&gt; [1] 0.6127013

rmse(obs, pred_means)
#&gt; [1] 5264.37

rmsle(obs, pred_means)
#&gt; [1] 1.934614

## Metric functions for survival probabilities
sensitivity(obs, pred_probs)
#&gt;      mean     time1     time2 
#&gt; 0.3451033 0.3477320 0.3424745

specificity(obs, pred_probs)
#&gt;      mean     time1     time2 
#&gt; 0.9323611 0.8647221 1.0000000</code></pre>
</div>
<div id="metric-information" class="section level2">
<h2>Metric Information</h2>
<p>A named list of available metrics can be obtained interactively with the <code>metricinfo()</code> function, and includes the following components for each one.</p>
<dl>
<dt><code>label</code></dt>
<dd>Character descriptor for the metric.
</dd>
<dt><code>maximize</code></dt>
<dd>Logical indicating whether higher values of the metric correspond to better predictive performance.
</dd>
<dt><code>arguments</code></dt>
<dd>Closure with the argument names and corresponding default values of the metric function.
</dd>
<dt><code>response_types</code></dt>
<dd>Data frame of the observed and predicted response variable types supported by the metric.
</dd>
</dl>
<p>Function <code>metricinfo()</code> may be called without arguments, with one or more metric functions, an observed response variable, an observed and predicted response variable pair, response variable types, or resampled output; and will return information on all matching metrics.</p>
<pre class="r"><code>## All available metrics
metricinfo() %&gt;% names
#&gt;  [1] &quot;accuracy&quot;        &quot;auc&quot;             &quot;brier&quot;           &quot;cindex&quot;         
#&gt;  [5] &quot;cross_entropy&quot;   &quot;f_score&quot;         &quot;fnr&quot;             &quot;fpr&quot;            
#&gt;  [9] &quot;gini&quot;            &quot;kappa2&quot;          &quot;mae&quot;             &quot;mse&quot;            
#&gt; [13] &quot;msle&quot;            &quot;npv&quot;             &quot;ppv&quot;             &quot;pr_auc&quot;         
#&gt; [17] &quot;precision&quot;       &quot;r2&quot;              &quot;recall&quot;          &quot;rmse&quot;           
#&gt; [21] &quot;rmsle&quot;           &quot;roc_auc&quot;         &quot;roc_index&quot;       &quot;rpp&quot;            
#&gt; [25] &quot;sensitivity&quot;     &quot;specificity&quot;     &quot;tnr&quot;             &quot;tpr&quot;            
#&gt; [29] &quot;weighted_kappa2&quot;</code></pre>
<p>Information is displayed below for the <code>cindex()</code> function corresponding to a concordance index, which is applicable to observed survival and predicted means.</p>
<pre class="r"><code>## Metric-specific information
metricinfo(cindex)
#&gt; $cindex
#&gt; $cindex$label
#&gt; [1] &quot;Concordance Index&quot;
#&gt; 
#&gt; $cindex$maximize
#&gt; [1] TRUE
#&gt; 
#&gt; $cindex$arguments
#&gt; function (observed, predicted = NULL, ...) 
#&gt; NULL
#&gt; 
#&gt; $cindex$response_types
#&gt;    observed predicted
#&gt; 1    factor   numeric
#&gt; 2 Resamples      NULL
#&gt; 3      Surv   numeric</code></pre>
<p>Submitting the metric function at the console will result in similar information being displayed as formatted text.</p>
<pre class="r"><code>cindex
#&gt; Object of class &quot;MLMetric&quot;
#&gt; 
#&gt; Metric name: cindex
#&gt; Label: Concordance Index
#&gt; Maximize: TRUE
#&gt; 
#&gt; Arguments:
#&gt; function (observed, predicted = NULL, ...) 
#&gt; NULL
#&gt; 
#&gt; Types:
#&gt;    observed predicted
#&gt; 1    factor   numeric
#&gt; 2 Resamples      NULL
#&gt; 3      Surv   numeric</code></pre>
<div id="type-specific-metrics" class="section level3">
<h3>Type-Specific Metrics</h3>
<p>When data objects are supplied as arguments to <code>metricinfo()</code>, information is returned on all metrics applicable to response variables of the same data types. Observed response variable type is inferred from the first data argument and predicted type from the second, if given. For survival responses, predicted types may be <code>numeric</code> for survival means, <code>SurvEvents</code> for 0-1 survival events at specified follow-up times, or <code>SurvProbs</code> for follow-up time survival probabilities. If model functions are additionally supplied as arguments, information on the subset matching the data types is returned.</p>
<pre class="r"><code>## Metrics for observed and predicted response variable types
metricinfo(Surv(0)) %&gt;% names
#&gt;  [1] &quot;accuracy&quot;    &quot;auc&quot;         &quot;brier&quot;       &quot;cindex&quot;      &quot;f_score&quot;    
#&gt;  [6] &quot;fnr&quot;         &quot;fpr&quot;         &quot;gini&quot;        &quot;kappa2&quot;      &quot;mae&quot;        
#&gt; [11] &quot;mse&quot;         &quot;msle&quot;        &quot;npv&quot;         &quot;ppv&quot;         &quot;pr_auc&quot;     
#&gt; [16] &quot;precision&quot;   &quot;r2&quot;          &quot;recall&quot;      &quot;rmse&quot;        &quot;rmsle&quot;      
#&gt; [21] &quot;roc_auc&quot;     &quot;roc_index&quot;   &quot;rpp&quot;         &quot;sensitivity&quot; &quot;specificity&quot;
#&gt; [26] &quot;tnr&quot;         &quot;tpr&quot;

metricinfo(Surv(0), numeric(0)) %&gt;% names
#&gt; [1] &quot;cindex&quot; &quot;gini&quot;   &quot;mae&quot;    &quot;mse&quot;    &quot;msle&quot;   &quot;r2&quot;     &quot;rmse&quot;   &quot;rmsle&quot;

metricinfo(Surv(0), SurvEvents(0)) %&gt;% names
#&gt;  [1] &quot;accuracy&quot;    &quot;f_score&quot;     &quot;fnr&quot;         &quot;fpr&quot;         &quot;kappa2&quot;     
#&gt;  [6] &quot;npv&quot;         &quot;ppv&quot;         &quot;precision&quot;   &quot;recall&quot;      &quot;roc_index&quot;  
#&gt; [11] &quot;rpp&quot;         &quot;sensitivity&quot; &quot;specificity&quot; &quot;tnr&quot;         &quot;tpr&quot;

metricinfo(Surv(0), SurvProbs(0)) %&gt;% names
#&gt;  [1] &quot;accuracy&quot;    &quot;auc&quot;         &quot;brier&quot;       &quot;f_score&quot;     &quot;fnr&quot;        
#&gt;  [6] &quot;fpr&quot;         &quot;kappa2&quot;      &quot;npv&quot;         &quot;ppv&quot;         &quot;pr_auc&quot;     
#&gt; [11] &quot;precision&quot;   &quot;recall&quot;      &quot;roc_auc&quot;     &quot;roc_index&quot;   &quot;rpp&quot;        
#&gt; [16] &quot;sensitivity&quot; &quot;specificity&quot; &quot;tnr&quot;         &quot;tpr&quot;

## Identify survival-specific metrics
metricinfo(Surv(0), auc, cross_entropy, cindex) %&gt;% names
#&gt; [1] &quot;auc&quot;    &quot;cindex&quot;</code></pre>
</div>
<div id="response-variable-specific-metrics" class="section level3">
<h3>Response Variable-Specific Metrics</h3>
<p>Existing response variables observed and those obtained from the <code>predict()</code> function may be given as arguments to identify metrics that are applicable to them.</p>
<pre class="r"><code>## Metrics for observed and predicted responses from model fits
metricinfo(obs, pred_means) %&gt;% names
#&gt; [1] &quot;cindex&quot; &quot;gini&quot;   &quot;mae&quot;    &quot;mse&quot;    &quot;msle&quot;   &quot;r2&quot;     &quot;rmse&quot;   &quot;rmsle&quot;

metricinfo(obs, pred_probs) %&gt;% names
#&gt;  [1] &quot;accuracy&quot;    &quot;auc&quot;         &quot;brier&quot;       &quot;f_score&quot;     &quot;fnr&quot;        
#&gt;  [6] &quot;fpr&quot;         &quot;kappa2&quot;      &quot;npv&quot;         &quot;ppv&quot;         &quot;pr_auc&quot;     
#&gt; [11] &quot;precision&quot;   &quot;recall&quot;      &quot;roc_auc&quot;     &quot;roc_index&quot;   &quot;rpp&quot;        
#&gt; [16] &quot;sensitivity&quot; &quot;specificity&quot; &quot;tnr&quot;         &quot;tpr&quot;</code></pre>
</div>
</div>
<div id="factors" class="section level2">
<h2>Factors</h2>
<p>Metrics applicable to multi-level factor response variables are summarized below.</p>
<dl>
<dt><code>accuracy()</code></dt>
<dd>Proportion of correctly classified responses.
</dd>
<dt><code>brier()</code></dt>
<dd><a href="https://en.wikipedia.org/wiki/Brier_score">Brier score</a>.
</dd>
<dt><code>cross_entropy()</code></dt>
<dd><a href="https://en.wikipedia.org/wiki/Cross_entropy">Cross entropy</a> loss averaged over the number of cases.
</dd>
<dt><code>kappa2()</code></dt>
<dd><a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa">Cohen’s kappa</a> statistic measuring relative agreement between observed and predicted classifications.
</dd>
<dt><code>weighted_kappa2()</code></dt>
<dd><a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa#Weighted_kappa">Weighted Cohen’s kappa</a> for ordered factor responses only.
</dd>
</dl>
<p>Brier score and cross entropy loss are computed directly on predicted class probabilities. The other metrics are computed on predicted class membership, defined as the factor level with the highest predicted probability.</p>
</div>
<div id="binary-factors" class="section level2">
<h2>Binary Factors</h2>
<p>Metrics for binary factors include those given for multi-level factors as well as the following.</p>
<dl>
<dt><code>auc()</code></dt>
<dd>Area under a performance curve.
</dd>
<dt><code>cindex()</code></dt>
<dd>Concordance index computed as rank order agreement between predicted probabilities for paired event and non-event cases. This metric can be interpreted as the probability that a randomly selected event case will have a higher predicted value than a randomly selected non-event case, and is the same as area under the ROC curve.
</dd>
<dt><code>f_score()</code></dt>
<dd><a href="https://en.wikipedia.org/wiki/Precision_and_recall#F-measure">F score</a>, <span class="math inline">\(F_\beta = (1 + \beta^2) \frac{\text{precision} \times \text{recall}}{\beta^2 \times \text{precision} + \text{recall}}\)</span>. F1 score <span class="math inline">\((\beta = 1)\)</span> is the package default.
</dd>
<dt><code>fnr()</code></dt>
<dd>False negative rate, <span class="math inline">\(FNR = \frac{FN}{TP + FN} = 1 - TPR\)</span>.
</dd>
</dl>
<table class="table" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
Table 4. Confusion matrix of observed and predicted response classifications.
</caption>
<thead>
<tr>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="1">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Predicted Response
</div>
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="2">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Observed Response
</div>
</th>
</tr>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:center;">
Negative
</th>
<th style="text-align:center;">
Positive
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Negative
</td>
<td style="text-align:center;">
True Negative (TN)
</td>
<td style="text-align:center;">
False Negative (FN)
</td>
</tr>
<tr>
<td style="text-align:left;">
Positive
</td>
<td style="text-align:center;">
False Positive (FP)
</td>
<td style="text-align:center;">
True Positive (TP)
</td>
</tr>
</tbody>
</table>
<dl>
<dt><code>fpr()</code></dt>
<dd>False positive rate, <span class="math inline">\(FPR = \frac{FP}{TN + FP} = 1 - TNR\)</span>.
</dd>
<dt><code>npv()</code></dt>
<dd>Negative predictive value, <span class="math inline">\(NPV = \frac{TN}{TN + FN}\)</span>.
</dd>
<dt><code>ppv()</code>, <code>precision()</code></dt>
<dd>Positive predictive value, <span class="math inline">\(PPV = \frac{TP}{TP + FP}\)</span>.
</dd>
<dt><code>pr_auc()</code>, <code>auc()</code></dt>
<dd>Area under a precision recall curve.
</dd>
<dt><code>roc_auc()</code>, <code>auc()</code></dt>
<dd><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve">Area under an ROC curve</a>.
</dd>
<dt><code>roc_index()</code></dt>
<dd>A tradeoff function of sensitivity and specificity as defined by the <code>f</code> argument in this function (default: sensitivity + specificity). The function allows for specification of tradeoffs <span class="citation">(Perkins and Schisterman 2006)</span> other than the default of Youden’s J statistic <span class="citation">(Youden 1950)</span>.
</dd>
<dt><code>rpp()</code></dt>
<dd>Rate of positive prediction, <span class="math inline">\(RPP = \frac{TP + FP}{TP + FP + TN + FN}\)</span>.
</dd>
<dt><code>sensitivity()</code>, <code>recall()</code>, <code>tpr()</code></dt>
<dd>True positive rate, <span class="math inline">\(TPR =\frac{TP}{TP + FN} = 1 - FNR\)</span>.
</dd>
<dt><code>specificity()</code>, <code>tnr()</code></dt>
<dd>True negative rate, <span class="math inline">\(TNR = \frac{TN}{TN + FP} = 1 - FPR\)</span>.
</dd>
</dl>
<p>Area under the ROC and precision-recall curves as well as the concordance index are computed directly on predicted class probabilities. The other metrics are computed on predicted class membership. Memberships are defined to be in the second factor level if predicted probabilities are greater than the function default or user-specified cutoff value.</p>
</div>
<div id="numerics" class="section level2">
<h2>Numerics</h2>
<p>Performance metrics are defined below for numeric vector responses. If applied to a numeric matrix response, the metrics are computed separately for each column and then averaged to produce a single value.</p>
<dl>
<dt><code>gini()</code></dt>
<dd><a href="https://en.wikipedia.org/wiki/Gini_coefficient">Gini coefficient</a>.
</dd>
<dt><code>mae()</code></dt>
<dd>Mean absolute error, <span class="math inline">\(MAE = \frac{1}{N}\sum_{i=1}^N|y_i - \hat{y}_i|\)</span>, where <span class="math inline">\(y_i\)</span> and <span class="math inline">\(\hat{y}_i\)</span> are the <span class="math inline">\(N\)</span> observed and predicted responses.
</dd>
<dt><code>mse()</code></dt>
<dd>Mean squared error, <span class="math inline">\(MSE = \frac{1}{N}\sum_{i=1}^N(y_i - \hat{y}_i)^2\)</span>.
</dd>
<dt><code>msle()</code></dt>
<dd>Mean squared log error, <span class="math inline">\(MSLE = \frac{1}{N}\sum_{i=1}^N(log(1 + y_i) - log(1 + \hat{y}_i))^2\)</span>.
</dd>
<dt><code>r2()</code></dt>
<dd>One minus residual divided by total sums of squares, <span class="math inline">\(R^2 = 1 - \sum_{i=1}^N(y_i - \hat{y}_i)^2 / \sum_{i=1}^N(y_i - \bar{y})^2\)</span>.
</dd>
<dt><code>rmse()</code></dt>
<dd>Square root of mean squared error.
</dd>
<dt><code>rmsle()</code></dt>
<dd>Square root of mean squared log error.
</dd>
</dl>
</div>
<div id="survival-objects-1" class="section level2">
<h2>Survival Objects</h2>
<p>All previously described metrics for binary factor responses—plus accuracy, Brier score and Cohen’s kappa—are applicable to survival probabilities predicted at specified follow-up times. Metrics are evaluated separately at each follow-up time and reported along with a time-integrated mean. The survival concordance index is computed with the method of Harrell <span class="citation">(1982)</span> and Brier score according to Graf et al. <span class="citation">(1999)</span>; whereas, the others are computed according to the confusion matrix probabilities below, in which term <span class="math inline">\(\hat{S}(t)\)</span> is the predicted survival probability at follow-up time <span class="math inline">\(t\)</span> and <span class="math inline">\(T\)</span> is the survival time <span class="citation">(Heagerty, Lumley, and Pepe 2004)</span>.</p>
<table class="table" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
Table 5. Confusion matrix of observed and predicted survival response classifications.
</caption>
<thead>
<tr>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="1">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Predicted Response
</div>
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="2">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Observed Response
</div>
</th>
</tr>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:center;">
Non-Event
</th>
<th style="text-align:center;">
Event
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Non-Event
</td>
<td style="text-align:center;">
<span class="math inline">\(TN = \Pr(\hat{S}(t) \gt \text{cutoff} \cap T \ge t)\)</span>
</td>
<td style="text-align:center;">
<span class="math inline">\(FN = \Pr(\hat{S}(t) \gt \text{cutoff} \cap T \lt t)\)</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
Event
</td>
<td style="text-align:center;">
<span class="math inline">\(FP = \Pr(\hat{S}(t) \le \text{cutoff} \cap T \ge t)\)</span>
</td>
<td style="text-align:center;">
<span class="math inline">\(TP = \Pr(\hat{S}(t) \le \text{cutoff} \cap T \lt t)\)</span>
</td>
</tr>
</tbody>
</table>
<p>In addition, all of the metrics described for numeric vector responses are applicable to predicted survival means and are computed using only those cases with observed (non-censored) events.</p>
</div>
</div>
<div id="resampled-performance" class="section level1">
<h1>Resampled Performance</h1>
<div id="algorithms" class="section level2">
<h2>Algorithms</h2>
<p>Model performance can be estimated with resampling methods that simulate repeated training and test set fits and predictions. With these methods, performance metrics are computed on each resample to produce an empirical distribution for inference. Resampling is controlled in the <strong>MachineShop</strong> with the functions:</p>
<dl>
<dt><code>BootControl()</code></dt>
<dd>Simple bootstrap resampling <span class="citation">(Efron and Tibshirani 1993)</span>. Models are repeatedly fit with bootstrap resampled training sets and used to predict the full dataset.
</dd>
<dt><code>BootOptimismControl()</code></dt>
<dd>Optimism-corrected bootstrap resampling <span class="citation">(Efron and Gong 1983; Harrell, Lee, and Mark 1996)</span>.
</dd>
<dt><code>CVControl()</code></dt>
<dd>Repeated K-fold cross-validation <span class="citation">(Kohavi 1995)</span>. The full dataset is repeatedly partitioned into K-folds. For a given partitioning, prediction is performed on each of the K folds with models fit on all remaining folds. 10-fold cross-validation is the package default.
</dd>
<dt><code>CVOptimismControl()</code></dt>
<dd>Optimism-corrected cross-validation <span class="citation">(Davison and Hinkley 1997, eq. 6.48)</span>.
</dd>
<dt><code>OOBControl()</code></dt>
<dd>Out-of-bootstrap resampling. Models are fit with bootstrap resampled training sets and used to predict the unsampled cases.
</dd>
<dt><code>SplitControl()</code></dt>
<dd>Split training and test sets <span class="citation">(Hastie, Tibshirani, and Friedman 2009)</span>. The data are randomly partitioned into a training and test set.
</dd>
<dt><code>TrainControl()</code></dt>
<dd>Training resubstitution. A model is fit on and used to predict the full training set in order to estimate training, or apparent, error <span class="citation">(Efron 1986)</span>.
</dd>
</dl>
<p>For the survival example, repeated cross-validation control structures are defined to estimate model performance in predicting survival means and 5 and 10-year survival probabilities. In addition to arguments controlling the resampling algorithms, a <code>seed</code> can be set to ensure reproducibility of resampling results obtained with the structures.</p>
<pre class="r"><code>## Control parameters for K-fold cross-validation

## Prediction of survival means
surv_means_control &lt;- CVControl(folds = 5, repeats = 3, seed = 123)

## Prediction of survival probabilities
surv_probs_control &lt;- CVControl(folds = 5, repeats = 3, times = surv_times, seed = 123)</code></pre>
</div>
<div id="parallel-processing" class="section level2">
<h2>Parallel Processing</h2>
<p>Resampling is implemented with the <strong>foreach</strong> package <span class="citation">(Microsoft and Weston 2019)</span> and will run in parallel if a compatible backend is loaded, such as that provided by the <strong>doParallel</strong> <span class="citation">(Microsoft Corporation and Weston 2019b)</span> or <strong>doSNOW</strong> package <span class="citation">(Microsoft Corporation and Weston 2019a)</span>.</p>
<pre class="r"><code>## Register multiple cores for parallel computations
library(doParallel)
registerDoParallel(cores = 2)</code></pre>
</div>
<div id="resample-function" class="section level2">
<h2>Resample Function</h2>
<p>Resampling is performed by calling the <code>resample()</code> function with a variable specification, model, and control structure. Like the <code>fit()</code> function, variables may be specified in terms of a traditional formula, design matrix, model frame, or recipe.</p>
<pre class="r"><code>## Resample estimation for survival means and probabilities
(res_means &lt;- resample(surv_fo, data = surv_train, model = GBMModel, control = surv_means_control))
#&gt; Object of class &quot;Resamples&quot;
#&gt; 
#&gt; Models: GBMModel
#&gt; Stratification variable: (strata) 
#&gt; 
#&gt; Object of class &quot;MLControl&quot;
#&gt; 
#&gt; Name: CVControl
#&gt; Label: K-Fold Cross-Validation
#&gt; Folds: 5
#&gt; Repeats: 3
#&gt; Seed: 123

(res_probs &lt;- resample(surv_fo, data = surv_train, model = GBMModel, control = surv_probs_control))
#&gt; Object of class &quot;Resamples&quot;
#&gt; 
#&gt; Models: GBMModel
#&gt; Stratification variable: (strata) 
#&gt; 
#&gt; Object of class &quot;MLControl&quot;
#&gt; 
#&gt; Name: CVControl
#&gt; Label: K-Fold Cross-Validation
#&gt; Folds: 5
#&gt; Repeats: 3
#&gt; Survival times: 1825, 3650
#&gt; Seed: 123</code></pre>
</div>
<div id="summary-statistics" class="section level2">
<h2>Summary Statistics</h2>
<p>The <code>summary()</code> function when applied directly to output from <code>resample()</code> computes summary statistics for the default performance metrics described in the <em>Performance Function</em> section.</p>
<pre class="r"><code>## Summary of survival means metric
summary(res_means)
#&gt;          Statistic
#&gt; Metric         Mean    Median         SD       Min       Max NA
#&gt;   C-Index 0.7610614 0.7663043 0.06966664 0.6256684 0.8924731  0

## Summary of survival probability metrics
summary(res_probs)
#&gt;                 Statistic
#&gt; Metric                Mean    Median         SD        Min       Max NA
#&gt;   Brier.mean     0.1864575 0.1714480 0.05565866 0.12160556 0.3389423  0
#&gt;   Brier.time1    0.1686271 0.1674014 0.03595483 0.09871495 0.2322408  0
#&gt;   Brier.time2    0.2042879 0.1782289 0.08490057 0.11394700 0.4511018  0
#&gt;   ROC AUC.mean   0.8027479 0.8042350 0.07424125 0.64150295 0.9649704  0
#&gt;   ROC AUC.time1  0.8095576 0.8165647 0.08239321 0.67817170 0.9736842  0
#&gt;   ROC AUC.time2  0.7959383 0.7841695 0.07576232 0.60483420 0.9562566  0
#&gt;   Accuracy.mean  0.7186462 0.7037037 0.06122749 0.63466287 0.8472222  0
#&gt;   Accuracy.time1 0.7614381 0.7500000 0.05727825 0.66419753 0.8888889  0
#&gt;   Accuracy.time2 0.6758544 0.6661055 0.08212921 0.55789621 0.8425926  0</code></pre>
<p>Other relevant metrics can be identified with <code>metricinfo()</code> and summarized with <code>performance()</code>.</p>
<pre class="r"><code>## Resample-specific metrics
metricinfo(res_means) %&gt;% names
#&gt; [1] &quot;cindex&quot; &quot;gini&quot;   &quot;mae&quot;    &quot;mse&quot;    &quot;msle&quot;   &quot;r2&quot;     &quot;rmse&quot;   &quot;rmsle&quot;

## User-specified survival means metrics
summary(performance(res_means, metrics = c(cindex, rmse)))
#&gt;         Statistic
#&gt; Metric           Mean       Median           SD          Min          Max NA
#&gt;   cindex    0.7610614    0.7663043 6.966664e-02    0.6256684    0.8924731  0
#&gt;   rmse   4016.4176835 3642.1226845 1.586513e+03 1792.6746614 8511.1333117  0</code></pre>
<p>Futhermore, summaries can be customized with a user-defined statistics function or list of statistics functions passed to the <code>stats</code> argument of <code>summary()</code>.</p>
<pre class="r"><code>## User-defined statistics function
percentiles &lt;- function(x) quantile(x, probs = c(0.25, 0.50, 0.75))
summary(res_means, stats = percentiles)
#&gt;          Statistic
#&gt; Metric         25%       50%       75% NA
#&gt;   C-Index 0.720087 0.7663043 0.8113255  0

## User-defined list of statistics functions
summary(res_means, stats = c(Mean = mean, Percentile = percentiles))
#&gt;          Statistic
#&gt; Metric         Mean Percentile.25% Percentile.50% Percentile.75% NA
#&gt;   C-Index 0.7610614       0.720087      0.7663043      0.8113255  0</code></pre>
</div>
<div id="plots" class="section level2">
<h2>Plots</h2>
<p>Summary plots of resample output can be obtained with the <code>plot()</code> function. Boxplots are the default plot type; but density, errorbar, and violin plots are also available. Plots are generated with the <strong>ggplot2</strong> package <span class="citation">(Wickham 2016)</span> and returned as <code>ggplot</code> objects. As such, annotation and formatting defined for ggplots can be applied to the returned plots.</p>
<pre class="r"><code>## Libraries for plot annotation and fomatting
library(ggplot2)
library(gridExtra)

## Individual ggplots
p1 &lt;- plot(res_means)
p2 &lt;- plot(res_means, type = &quot;density&quot;)
p3 &lt;- plot(res_means, type = &quot;errorbar&quot;)
p4 &lt;- plot(res_means, type = &quot;violin&quot;)

## Grid of plots
grid.arrange(p1, p2, p3, p4, nrow = 2)</code></pre>
<p><img src="using_files/figure-html/using_resample_plots-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="stratified-resampling" class="section level2">
<h2>Stratified Resampling</h2>
<p>Stratification of cases for the construction of resampled training and test sets can be employed to help achieve balance across the sets. Stratified resampling is automatically performed if variable specification is in terms of a traditional formula and will be done according to the response variable if a numeric vector or factor, the event variable if survival, and the first variable if a numeric matrix. For model frames and recipes, stratification variables must be defined explicitly with the <code>strata</code> argument to the <code>ModelFrame()</code> constructor or with the <code>role_case()</code> function.</p>
<pre class="r"><code>## Model frame with case status stratification
mf &lt;- ModelFrame(surv_fo, data = surv_train, strata = surv_train$status)
resample(mf, model = GBMModel)

## Recipe with case status stratification
rec &lt;- recipe(time + status ~ ., data = surv_train) %&gt;%
  role_surv(time = time, event = status) %&gt;%
  role_case(stratum = status)
resample(rec, model = GBMModel)</code></pre>
</div>
<div id="dynamic-model-parameters-1" class="section level2">
<h2>Dynamic Model Parameters</h2>
<p>As discussed previously in the <em>Model Fit and Prediction</em> section, dynamic model parameters are evaluated at the time of model fitting and can depend on the number of observations in the fitted dataset. In the context of resampling, dynamic parameters are repeatedly evaluated at each fit of the resampled datasets. As such, their values can change based on the observations selected for training at each iteration of the resampling algorithm.</p>
<pre class="r"><code>## Dynamic model parameter k = log number of training set observations
resample(surv_fo, data = surv_train, model = CoxStepAICModel(k = .(log(nobs))))</code></pre>
</div>
<div id="model-comparisons" class="section level2">
<h2>Model Comparisons</h2>
<p>Resampled metrics from different models can be combined for comparison with the <code>c()</code> function. Optional names given on the left hand side of equal operators within <code>c()</code> calls will be used as labels in output from the <code>summary()</code> and <code>plot()</code> functions. For comparisons of resampled output, the same control structure must be used in all associated calls to <code>resample()</code> to ensure that resulting model metrics are computed on the same resampled training and test sets. The combined resample output can be summarized and plotted as usual.</p>
<pre class="r"><code>## Resample estimation
res1 &lt;- resample(surv_fo, data = surv_train, model = GBMModel(n.trees = 25),
                 control = surv_means_control)
res2 &lt;- resample(surv_fo, data = surv_train, model = GBMModel(n.trees = 50),
                 control = surv_means_control)
res3 &lt;- resample(surv_fo, data = surv_train, model = GBMModel(n.trees = 100),
                 control = surv_means_control)

## Combine resample output for comparison
(res &lt;- c(GBM1 = res1, GBM2 = res2, GBM3 = res3))
#&gt; Object of class &quot;Resamples&quot;
#&gt; 
#&gt; Models: GBM1, GBM2, GBM3
#&gt; Stratification variable: (strata) 
#&gt; 
#&gt; Object of class &quot;MLControl&quot;
#&gt; 
#&gt; Name: CVControl
#&gt; Label: K-Fold Cross-Validation
#&gt; Folds: 5
#&gt; Repeats: 3
#&gt; Seed: 123

summary(res)
#&gt; , , Metric = C-Index
#&gt; 
#&gt;       Statistic
#&gt; Model       Mean    Median         SD       Min       Max NA
#&gt;   GBM1 0.7738602 0.7743590 0.08222939 0.6096257 0.9354839  0
#&gt;   GBM2 0.7730294 0.7692308 0.07206580 0.6363636 0.9354839  0
#&gt;   GBM3 0.7610614 0.7663043 0.06966664 0.6256684 0.8924731  0

plot(res)</code></pre>
<p><img src="using_files/figure-html/using_resample_comparisons-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Pairwise model differences for each metric can be calculated with the <code>diff()</code> function applied to results from a call to <code>c()</code>. Resulting differences can be summarized descriptively with the <code>summary()</code> and <code>plot()</code> functions and assessed for statistical significance with pairwise t-test performed by the <code>t.test()</code> function.</p>
<pre class="r"><code>## Pairwise model comparisons
(res_diff &lt;- diff(res))
#&gt; Object of class &quot;PerformanceDiff&quot;
#&gt; 
#&gt; Metrics: C-Index 
#&gt; Models: GBM1 - GBM2, GBM1 - GBM3, GBM2 - GBM3

summary(res_diff)
#&gt; , , Metric = C-Index
#&gt; 
#&gt;              Statistic
#&gt; Model                 Mean      Median         SD         Min        Max NA
#&gt;   GBM1 - GBM2 0.0008308229 0.005128205 0.01863138 -0.03482587 0.02331606  0
#&gt;   GBM1 - GBM3 0.0127988563 0.008982036 0.02271720 -0.01990050 0.05434783  0
#&gt;   GBM2 - GBM3 0.0119680334 0.010695187 0.01992512 -0.02590674 0.04891304  0

plot(res_diff)</code></pre>
<p><img src="using_files/figure-html/using_resample_diff-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>t.test(res_diff)
#&gt; Object of class &quot;PerformanceDiffTest&quot;
#&gt; 
#&gt; Upper diagonal: mean differences (Model1 - Model2)
#&gt; Lower diagonal: p-values
#&gt; P-value adjustment method: holm
#&gt; 
#&gt; , , Metric = C-Index
#&gt; 
#&gt;       Model2
#&gt; Model1      GBM1         GBM2       GBM3
#&gt;   GBM1        NA 0.0008308229 0.01279886
#&gt;   GBM2 0.8653540           NA 0.01196803
#&gt;   GBM3 0.1065908 0.1065908159         NA</code></pre>
</div>
</div>
<div id="model-predictor-effects-and-diagnostics" class="section level1">
<h1>Model Predictor Effects and Diagnostics</h1>
<p>Calculation of performance metrics on test sets or by resampling, as discussed previously, is one method of assessing model performance. Others available include measures of predictor variable importance, partial dependence plots, calibration curves comparing observed and predicted response values, and receiver operating characteristic analysis.</p>
<div id="variable-importance" class="section level2">
<h2>Variable Importance</h2>
<p>The importance of predictor variables in a model fit is estimated with the <code>varimp()</code> function and displayed graphically with <code>plot()</code>. Variable importance is a relative measure of the contributions of model predictors and has a default range of 0 to 100, where 0 denotes the least important variables and 100 the most. Classes of models can differ with respect to how variable importance is defined. In the case of a <code>GBMModel</code>, importance of each predictor is based on the sum of squared empirical improvements over all internal tree nodes created by splitting on that variable <span class="citation">(Greenwell et al. 2019)</span>.</p>
<pre class="r"><code>## Predictor variable importance
(vi &lt;- varimp(surv_fit))
#&gt; Object of class &quot;VarImp&quot;
#&gt;             Overall
#&gt; age       100.00000
#&gt; thickness  96.67023
#&gt; year       54.34984
#&gt; ulcer      25.68188
#&gt; sex         0.00000

plot(vi)</code></pre>
<p><img src="using_files/figure-html/using_analyses_vi-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Alternatively, importance is based on negative log-transformed p-values for statistical models, like <code>CoxModel</code>, that produce them. For other models, variable importance may be defined and calculated by their underlying source packages or not defined at all, as is the case for <code>SVMModel</code>. Logical indicators of the availability of variable importance are available in the printed model constructor information or from <code>modelinfo()</code>.</p>
<pre class="r"><code>SVMModel
#&gt; Object of class &quot;MLModelFunction&quot;
#&gt; 
#&gt; Model name: SVMModel
#&gt; Label: Support Vector Machines
#&gt; Package: kernlab
#&gt; Response types: factor, numeric
#&gt; Tuning grid: FALSE
#&gt; Variable importance: FALSE
#&gt; 
#&gt; Arguments:
#&gt; function (scaled = TRUE, type = NULL, kernel = c(&quot;rbfdot&quot;, &quot;polydot&quot;, 
#&gt;     &quot;vanilladot&quot;, &quot;tanhdot&quot;, &quot;laplacedot&quot;, &quot;besseldot&quot;, &quot;anovadot&quot;, 
#&gt;     &quot;splinedot&quot;), kpar = &quot;automatic&quot;, C = 1, nu = 0.2, epsilon = 0.1, 
#&gt;     cache = 40, tol = 0.001, shrinking = TRUE) 
#&gt; NULL

modelinfo(SVMModel)[[1]]$varimp
#&gt; [1] FALSE</code></pre>
</div>
<div id="partial-dependence-plots" class="section level2">
<h2>Partial Dependence Plots</h2>
<p>Partial dependence plots show the marginal effects of predictors on a response variable. Dependence for a select set of one or more predictor variables <span class="math inline">\(X_S\)</span> is computed as <span class="math display">\[
\bar{f}_S(X_S) = \frac{1}{N}\sum_{i=1}^N f(X_S, x_{iS&#39;}),
\]</span> where <span class="math inline">\(f\)</span> is a fitted prediction function and <span class="math inline">\(x_{iS&#39;}\)</span> are values of the remaining predictors in a dataset of <span class="math inline">\(N\)</span> cases. The response scale displayed in dependence plots will depend on the response variable type: probability for predicted factors and survival probabilities, original scale for numerics, and survival time for predicted survival means. By default, dependence is computed for each selected predictor individually over a grid of 10 approximately evenly spaced values and averaged over the dataset on which the prediction function was fit.</p>
<pre class="r"><code>## Partial dependence plots
pd &lt;- dependence(surv_fit, select = c(thickness, age))
plot(pd)</code></pre>
<p><img src="using_files/figure-html/using_analyses_pd-1.png" width="672" style="display: block; margin: auto;" /><img src="using_files/figure-html/using_analyses_pd-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Estimated predictor effects are marginal in that they are averaged over the remaining variables, whose distribution depends on the population represented by the dataset. Consequently, partial dependence plots for a given model can vary across datasets and populations. The package allows averaging over different datasets to estimate marginal effects in other case populations, over different numbers of predictor values, and over quantile spacing of the values.</p>
<pre class="r"><code>pd &lt;- dependence(surv_fit, data = surv_test, select = thickness, n = 20,
                 intervals = &quot;quantile&quot;)
plot(pd)</code></pre>
<p><img src="using_files/figure-html/using_analyses_pd_data-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>In addition, dependence may be computed for combinations of multiple predictors to examine interaction effects and for summary statistics other than the mean.</p>
</div>
<div id="calibration-curves" class="section level2">
<h2>Calibration Curves</h2>
<p>Agreement between model-predicted and observed values can be visualized with calibration curves. Calibration curves supplement individual performance metrics with information on model fit in different regions of predicted values. They also provide more direct assessment of agreement than some performance metrics, like ROC AUC, that do not account for scale and location differences. In the construction of binned calibration curves, cases are partitioned into equal-width intervals according to their (resampled) predicted responses. Mean observed responses are then calculated within each of the bins and plotted on the vertical axis against the bin midpoints on the horizontal axis.</p>
<pre class="r"><code>## Binned calibration curves
cal &lt;- calibration(res_probs, breaks = 10)
plot(cal, se = TRUE)</code></pre>
<p><img src="using_files/figure-html/using_analyses_cal-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>As an alternative to discrete bins, curves can be smoothed by setting <code>breaks = NULL</code> to compute weighted averages of observed values. Smoothing has the advantage of producing more precise curves by including more observed values in the calculation at each predicted value.</p>
<pre class="r"><code>## Smoothed calibration curves
cal &lt;- calibration(res_probs, breaks = NULL)
plot(cal)</code></pre>
<p><img src="using_files/figure-html/using_analyses_cal_smoothed-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Calibration curves close to the 45<span class="math inline">\(^\circ\)</span> line represent agreement between observed and predicted responses and a model that is said to be well calibrated.</p>
</div>
<div id="confusion-matrices" class="section level2">
<h2>Confusion Matrices</h2>
<p>Confusion matrices of cross-classified observed and predicted categorical responses are available with the <code>confusion()</code> function. They can be constructed with predicted class membership or with predicted class probabilities. In the latter case, predicted class membership is derived from predicted probabilities according to a probability cutoff value for binary factors (default: <code>cutoff = 0.5</code>) and according to the class with highest probability for factors with more than two levels.</p>
<pre class="r"><code>## Confusion matrices
(conf &lt;- confusion(res_probs, cutoff = 0.7))
#&gt; Object of class &quot;ConfusionList&quot;
#&gt; 
#&gt; GBMModel.time1 :
#&gt; Object of class &quot;BinaryConfusionMatrix&quot;
#&gt;          Observed
#&gt; Predicted         0         1
#&gt;         0 234.22792  38.77208
#&gt;         1  61.45833  73.54167
#&gt; ------------------------------------------------------------ 
#&gt; GBMModel.time2 :
#&gt; Object of class &quot;BinaryConfusionMatrix&quot;
#&gt;          Observed
#&gt; Predicted         0         1
#&gt;         0 168.94847  40.05153
#&gt;         1  81.92626 117.07374</code></pre>
<pre class="r"><code>plot(conf)</code></pre>
<p><img src="using_files/figure-html/using_analyses_conf_plot-1.png" width="672" style="display: block; margin: auto;" /><img src="using_files/figure-html/using_analyses_conf_plot-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Confusion matrices are the data structure upon which many of the performance metrics described earlier for factor predictor variables are based. Metrics commonly reported for confusion matrices are generated by the <code>summary()</code> function.</p>
<pre class="r"><code>## Summary performance metrics
summary(conf)
#&gt; GBMModel.time1 :
#&gt; Number of responses: 408
#&gt; Accuracy (SE): 0.7543372 (0.02131191)
#&gt; Majority class: 0.7247212
#&gt; Kappa: 0.4205949
#&gt; 
#&gt;                     0         1
#&gt; Observed    0.7247212 0.2752788
#&gt; Predicted   0.6691176 0.3308824
#&gt; Agreement   0.5740880 0.1802492
#&gt; Sensitivity 0.7921502 0.6547878
#&gt; Specificity 0.6547878 0.7921502
#&gt; PPV         0.8579777 0.5447531
#&gt; NPV         0.5447531 0.8579777
#&gt; ------------------------------------------------------------ 
#&gt; GBMModel.time2 :
#&gt; Number of responses: 408
#&gt; Accuracy (SE): 0.7010348 (0.0226647)
#&gt; Majority class: 0.614889
#&gt; Kappa: 0.3986831
#&gt; 
#&gt;                     0         1
#&gt; Observed    0.6148890 0.3851110
#&gt; Predicted   0.5122549 0.4877451
#&gt; Agreement   0.4140894 0.2869454
#&gt; Sensitivity 0.6734376 0.7450981
#&gt; Specificity 0.7450981 0.6734376
#&gt; PPV         0.8083659 0.5883102
#&gt; NPV         0.5883102 0.8083659</code></pre>
<p>Summaries can also be obtained with the <code>performance()</code> function for default or use-specified metrics.</p>
<pre class="r"><code>## Confusion matrix-specific metrics
metricinfo(conf) %&gt;% names
#&gt;  [1] &quot;accuracy&quot;    &quot;f_score&quot;     &quot;fnr&quot;         &quot;fpr&quot;         &quot;kappa2&quot;     
#&gt;  [6] &quot;npv&quot;         &quot;ppv&quot;         &quot;precision&quot;   &quot;recall&quot;      &quot;roc_index&quot;  
#&gt; [11] &quot;rpp&quot;         &quot;sensitivity&quot; &quot;specificity&quot; &quot;tnr&quot;         &quot;tpr&quot;

## User-specified metrics
performance(conf, metrics = c(&quot;Accuracy&quot; = accuracy,
                              &quot;Sensitivity&quot; = sensitivity,
                              &quot;Specificity&quot; = specificity))
#&gt; GBMModel.time1 :
#&gt;    Accuracy Sensitivity Specificity 
#&gt;   0.7543372   0.6547878   0.7921502 
#&gt; ------------------------------------------------------------ 
#&gt; GBMModel.time2 :
#&gt;    Accuracy Sensitivity Specificity 
#&gt;   0.7010348   0.7450981   0.6734376</code></pre>
</div>
<div id="performance-curves" class="section level2">
<h2>Performance Curves</h2>
<p>Tradeoffs between correct and incorrect classifications of binary responses, across the range of possible cutoff probabilities, can be studied with performance curves. In general, any two binary response metrics may be specified for the construction of a performance curve.</p>
<div id="roc-curves" class="section level3">
<h3>ROC Curves</h3>
<p>Receiver operating characteristic (ROC) curves are one example in which true positive rates (sensitivity) are plotted against false positive rates (1 - specificity) <span class="citation">(Fawcett 2006)</span>. True positive rate (TPR) and false positive rate (FPR) are defined as <span class="math display">\[
\begin{aligned}
 TPR &amp;= \text{sensitivity} = \Pr(\hat{p} &gt; c \mid D^+) \\
 FPR &amp;= 1 - \text{specificity} = \Pr(\hat{p} &gt; c \mid D^-),
\end{aligned}
\]</span> where <span class="math inline">\(\hat{p}\)</span> is the model-predicted probability of being positive, <span class="math inline">\(0 \le c \le 1\)</span> is a probability cutoff value for classification as positive or negative, and <span class="math inline">\(D^+/D^-\)</span> is positive/negative case status. ROC curves show tradeoffs between the two rates over the range of possible cutoff values. Higher curves are indicative of better predictive performance.</p>
<pre class="r"><code>## ROC curves
roc &lt;- performance_curve(res_probs)
plot(roc, diagonal = TRUE)</code></pre>
<p><img src="using_files/figure-html/using_analyses_roc-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>ROC curves show the relation between the two rates being plotted but not their relationships with specific cutoff values. The latter may be helpful for the selection of a cutoff to apply in practice. Accordingly, separate plots of each rate versus the range of possible cutoffs are available with the <code>type = "cutoffs"</code> option.</p>
<pre class="r"><code>plot(roc, type = &quot;cutoffs&quot;)</code></pre>
<p><img src="using_files/figure-html/using_analyses_roc_cutoffs-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Area under the ROC curve (ROC AUC) is an overall measure of model predictive performance. It is interpreted as the probability that a randomly selected positive case will have a higher predicted value than a randomly selected negative case. AUC values of 0.5 and 1.0 indicate chance and perfect <em>concordance</em> between predicted probabilities and observed responses.</p>
<pre class="r"><code>auc(roc)
#&gt; Model: GBMModel.time1
#&gt; [1] 0.7946513
#&gt; ------------------------------------------------------------ 
#&gt; Model: GBMModel.time2
#&gt; [1] 0.7823709</code></pre>
</div>
<div id="precision-recall-curves" class="section level3">
<h3>Precision Recall Curves</h3>
<p>Precision recall curves plot precision (positive predictive value) against recall (sensitivity) <span class="citation">(Davis and Goadrich 2006)</span>, where <span class="math display">\[
\begin{aligned}
  \text{precision} &amp;= PPV = \Pr(D^+ \mid \hat{p} &gt; c) \\
  \text{recall} &amp;= \text{sensitivity} = \Pr(\hat{p} &gt; c \mid D^+).
\end{aligned}
\]</span> These curves tend to be used when primary interest lies in detecting positive cases and such cases are rare.</p>
<pre class="r"><code>## Precision recall curves
pr &lt;- performance_curve(res_probs, metrics = c(precision, recall))
plot(pr)</code></pre>
<p><img src="using_files/figure-html/using_analyses_pr-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>auc(pr)
#&gt; Model: GBMModel.time1
#&gt; [1] 0.5527824
#&gt; ------------------------------------------------------------ 
#&gt; Model: GBMModel.time2
#&gt; [1] 0.6423603</code></pre>
</div>
<div id="lift-curves" class="section level3">
<h3>Lift Curves</h3>
<p>Lift curves depict the rate at which positive cases are found as a function of the proportion predicted to be positive in the population. In particular, they plot true positive rate (sensitivity) against positive prediction rate (PPR) for all possible classification probability cutoffs, where <span class="math display">\[
\begin{aligned}
  TPR &amp;= \Pr(\hat{p} &gt; c \mid D^+) \\
  PPR &amp;= \Pr(\hat{p} &gt; c).
\end{aligned}
\]</span> Models more efficient (lower cost) at identifying positive cases find them at a higher proportion (<span class="math inline">\(TPR\)</span>) while predicting fewer in the overall population to be positive (<span class="math inline">\(PPR\)</span>). In other words, higher lift curves are signs of model efficiency.</p>
<pre class="r"><code>## Lift curves
lf &lt;- lift(res_probs)
plot(lf, find = 0.75)</code></pre>
<p><img src="using_files/figure-html/using_analyses_lift-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
</div>
<div id="modeling-strategies" class="section level1">
<h1>Modeling Strategies</h1>
<p>Model development often involves the comparison of multiple models from a candidate set for the purpose of selecting a final one. Models in the set may differ with respect to their predictor variables, preprocessing steps and parameters, and model types and parameters. Complex model selection strategies for sets that involve one or more of these differences can be implemented with the <strong>MachineShop</strong> package. Implementation is achieved with a straightforward syntax based on the meta-input and meta-model functions listed in the table below and with resampling, including nested resampling, conducted automatically for model selection and predictive performance evaluation.</p>
<table>
<thead>
<tr class="header">
<th>Parameter Grid Tuning</th>
<th>Candidate Set Selection</th>
<th>Ensemble Learning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>TunedInput()</code></td>
<td><code>SelectedInput()</code></td>
<td><code>StackedModel()</code></td>
</tr>
<tr class="even">
<td><code>TunedModel()</code></td>
<td><code>SelectedModel()</code></td>
<td><code>SuperModel()</code></td>
</tr>
</tbody>
</table>
<p>These meta-functions fall into three main categories: 1) tuning of a given input or model over a grid of parameter values, 2) selection from an arbitrary set of different inputs or models, or 3) combining multiple models into an ensemble learner. In the context of these strategies, an input may be a formula, design matrix, model frame, or preprocessing recipe. The meta-input and meta-model functions themselves return input and model class objects, respectively. Combinations and multiple levels of nesting of meta-functions, inputs, and models are allowed. For example, <code>StackedModel()</code> and <code>SuperModel()</code> may consist of <code>TunedModel</code> and other model objects. <code>SelectedModel()</code> can select among mixes of <code>TunedModel</code>, ensemble model, and other model objects. Likewise, <code>TunedInput</code> objects, along with other inputs, may be nested within <code>SelectedInput()</code>. Furthermore, selection and tuning of both inputs and models can be performed simultaneously. These and other possibilities are illustrated in the following sections.</p>
<div id="inputs" class="section level2">
<h2>Inputs</h2>
<p>Inputs to model fitting functions define the predictor and response variables and the dataset containing their values. These can be specified with traditional formula and dataset pairs, design matrix and response variable pairs, model frames, and preprocessing recipes. The package supports (1) tuning of an input over a grid of parameter values and (2) selection of inputs from candidate sets that differ with respect to their predictors or their preprocessing steps and parameters.</p>
<div id="input-tuning" class="section level3">
<h3>Input Tuning</h3>
<p>Preprocessing recipes may have step with parameters that affect predictive performance. Steps can be tuned over a grid of parameter values with <code>TunedInput()</code> to select the best performing values. Calls to <code>TunedInput()</code> return an input object that may be trained on data with the <code>fit()</code> function or evaluated for predictive performance with <code>resample()</code>. As an example, a principal components analysis (PCA) step could be included in a preprocessing recipe for tuning over the number of components to retain in the final model. Such a recipe is shown below accompanied by a call to <code>expand_steps()</code> to construct a tuning grid. The grid parameter <code>num_comp</code> and name <code>PCA</code> correspond to the argument and id of the <code>step_pca()</code> function to which the values <code>1:3</code> apply. The recipe and grid may then be passed to <code>TunedInput()</code> for model fitting.</p>
<pre class="r"><code>## Preprocessing recipe with PCA steps
pca_rec &lt;- recipe(time + status ~ ., data = surv_train) %&gt;%
  role_surv(time = time, event = status) %&gt;%
  step_center(all_predictors()) %&gt;%
  step_scale(all_predictors()) %&gt;%
  step_pca(all_predictors(), id = &quot;PCA&quot;)

## Tuning grid of number of PCA components
pca_grid &lt;- expand_steps(
  PCA = list(num_comp = 1:3)
)

## Tuning specification
tun_rec &lt;- TunedInput(pca_rec, grid = pca_grid)</code></pre>
<p>From the fit, the resulting model can be extracted with <code>as.MLModel()</code>. The output shows that one principal component was selected. Resample estimation of predictive performance is applied to a <code>TunedInput</code> specification for the selection. The default resampling method is cross-validation. Other methods, performance metrics, and selection statistics can be supplied to the <code>TunedInput()</code> arguments.</p>
<pre class="r"><code>## Input-tuned model fit and final trained model
model_fit &lt;- fit(tun_rec, model = GBMModel)
as.MLModel(model_fit)
#&gt; Object of class &quot;MLModel&quot;
#&gt; 
#&gt; Model name: GBMModel
#&gt; Label: Trained Generalized Boosted Regression
#&gt; Package: gbm
#&gt; Response types: factor, numeric, PoissonVariate, Surv
#&gt; Tuning grid: TRUE
#&gt; Variable importance: TRUE
#&gt; 
#&gt; Parameters:
#&gt; List of 5
#&gt;  $ n.trees          : num 100
#&gt;  $ interaction.depth: num 1
#&gt;  $ n.minobsinnode   : num 10
#&gt;  $ shrinkage        : num 0.1
#&gt;  $ bag.fraction     : num 0.5
#&gt; 
#&gt; TrainStep1 :
#&gt; Object of class &quot;TrainBit&quot;
#&gt; 
#&gt; Grid (selected = 3):
#&gt; # A tibble: 3 x 1
#&gt;   ModelRecipe$PCA$num_comp
#&gt;                      &lt;int&gt;
#&gt; 1                        1
#&gt; 2                        2
#&gt; 3                        3
#&gt; 
#&gt; Object of class &quot;Performance&quot;
#&gt; 
#&gt; Metrics: C-Index 
#&gt; Models: 1, 2, 3
#&gt; 
#&gt; Selected model: 3 
#&gt; C-Index value: 0.7241954</code></pre>
</div>
<div id="input-selection" class="section level3">
<h3>Input Selection</h3>
<p>Selection of recipes with different steps or predictors can be conducted with <code>SelectedInput()</code>.</p>
<pre class="r"><code>## Preprocessing recipe without PCA steps
rec1 &lt;- recipe(time + status ~ sex + age + year + thickness + ulcer, data = surv_train) %&gt;%
  role_surv(time = time, event = status)
rec2 &lt;- recipe(time + status ~ sex + age + year, data = surv_train) %&gt;%
  role_surv(time = time, event = status)

## Selection among recipes with and without PCA steps
sel_rec &lt;- SelectedInput(
  rec1,
  rec2,
  TunedInput(pca_rec, grid = pca_grid)
)</code></pre>
<p>In this case, the first recipe with all original predictors and no PCA steps is selected.</p>
<pre class="r"><code>## Input-selected model fit and model
model_fit &lt;- fit(sel_rec, model = GBMModel)
as.MLModel(model_fit)
#&gt; Object of class &quot;MLModel&quot;
#&gt; 
#&gt; Model name: GBMModel
#&gt; Label: Trained Generalized Boosted Regression
#&gt; Package: gbm
#&gt; Response types: factor, numeric, PoissonVariate, Surv
#&gt; Tuning grid: TRUE
#&gt; Variable importance: TRUE
#&gt; 
#&gt; Parameters:
#&gt; List of 5
#&gt;  $ n.trees          : num 100
#&gt;  $ interaction.depth: num 1
#&gt;  $ n.minobsinnode   : num 10
#&gt;  $ shrinkage        : num 0.1
#&gt;  $ bag.fraction     : num 0.5
#&gt; 
#&gt; TrainStep1 :
#&gt; Object of class &quot;TrainBit&quot;
#&gt; 
#&gt; Grid (selected = 1):
#&gt; # A tibble: 3 x 1
#&gt;   ModelRecipe
#&gt;   &lt;fct&gt;      
#&gt; 1 1          
#&gt; 2 2          
#&gt; 3 3          
#&gt; 
#&gt; Object of class &quot;Performance&quot;
#&gt; 
#&gt; Metrics: C-Index 
#&gt; Models: Recipe.1, Recipe.2, Recipe.3
#&gt; 
#&gt; Selected model: Recipe.1 
#&gt; C-Index value: 0.7311282</code></pre>
<p>Selection can also be performed among traditional formulas, design matrices, or model frames.</p>
<pre class="r"><code>## Traditional formulas
fo1 &lt;- Surv(time, status) ~ sex + age + year + thickness + ulcer
fo2 &lt;- Surv(time, status) ~ sex + age + year

## Selection among formulas
sel_fo &lt;- SelectedInput(fo1, fo2, data = surv_train)

## Input-selected model fit and final trained model
model_fit &lt;- fit(sel_fo, model = GBMModel)
as.MLModel(model_fit)</code></pre>
<p>In the previous examples, selection of different inputs was performed with the same model (<code>GBMModel</code>). Selection among different combinations of inputs and models is supported with the <code>ModeledInput()</code> constructor.</p>
<pre class="r"><code>## Different combinations of inputs and models
sel_mfo &lt;- SelectedInput(
  ModeledInput(fo1, data = surv_train, model = CoxModel),
  ModeledInput(fo2, data = surv_train, model = GBMModel)
)

## Input-selected model fit and final trained model
model_fit &lt;- fit(sel_mfo)
as.MLModel(model_fit)</code></pre>
</div>
</div>
<div id="models" class="section level2">
<h2>Models</h2>
<p>Models define the functional relationships between predictor and response variables from a given set of inputs.</p>
<div id="model-tuning" class="section level3">
<h3>Model Tuning</h3>
<p>Many of the package-supplied modeling functions have arguments, or tuning parameters, that control aspects of their model fitting algorithms. For example, <code>GBMModel</code> parameters <code>n.trees</code> and <code>interaction.depth</code> control the number of decision trees to fit and the maximum tree depths. When called with a <code>TunedModel</code>, the <code>fit()</code> function performs model fitting over a grid of parameter values and returns the model with the most optimal values. Optimality is determined based on the first performance metric of the <code>metrics</code> argument to <code>TunedModel()</code> if given or the first default metric of the <code>performance()</code> function otherwise. Argument <code>grid</code> additionally controls the construction of grid values and can be a single numeric value giving the grid length in each parameter dimension. As shown in the output below, <code>as.MLModel()</code> will extract a tuned model from fit results for viewing of the tuning parameter grid values, the names of models fit to each, all calculated metrics, the final model selected, the metric upon which its selection was based, and its tuning parameters.</p>
<pre class="r"><code>## Tune over automatic grid of model parameters
model_fit &lt;- fit(surv_fo, data = surv_train,
                 model = TunedModel(
                   GBMModel,
                   grid = 3,
                   control = surv_means_control,
                   metrics = c(&quot;CIndex&quot; = cindex, &quot;RMSE&quot; = rmse)
                 ))
(trained_model &lt;- as.MLModel(model_fit))
#&gt; Object of class &quot;MLModel&quot;
#&gt; 
#&gt; Model name: GBMModel
#&gt; Label: Trained Generalized Boosted Regression
#&gt; Package: gbm
#&gt; Response types: factor, numeric, PoissonVariate, Surv
#&gt; Tuning grid: TRUE
#&gt; Variable importance: TRUE
#&gt; 
#&gt; Parameters:
#&gt; List of 5
#&gt;  $ n.trees          : num 50
#&gt;  $ interaction.depth: int 1
#&gt;  $ n.minobsinnode   : num 10
#&gt;  $ shrinkage        : num 0.1
#&gt;  $ bag.fraction     : num 0.5
#&gt; 
#&gt; TrainStep1 :
#&gt; Object of class &quot;TrainBit&quot;
#&gt; 
#&gt; Grid (selected = 1):
#&gt; # A tibble: 9 x 1
#&gt;   Model$n.trees $interaction.depth
#&gt;           &lt;dbl&gt;              &lt;int&gt;
#&gt; 1            50                  1
#&gt; 2           100                  1
#&gt; 3           150                  1
#&gt; 4            50                  2
#&gt; 5           100                  2
#&gt; 6           150                  2
#&gt; 7            50                  3
#&gt; 8           100                  3
#&gt; 9           150                  3
#&gt; 
#&gt; Object of class &quot;Performance&quot;
#&gt; 
#&gt; Metrics: CIndex, RMSE 
#&gt; Models: GBMModel.1, GBMModel.2, GBMModel.3, GBMModel.4, GBMModel.5, GBMModel.6,
#&gt;   GBMModel.7, GBMModel.8, GBMModel.9
#&gt; 
#&gt; Selected model: GBMModel.1 
#&gt; CIndex value: 0.7730294</code></pre>
<p>Grid values may also be a call to <code>Grid()</code> with the grid <code>length</code> and number of grid points to sample at <code>random</code>, a user-defined grid of points specified with the <code>expand_params()</code> function, or a data frame of grid points (not shown).</p>
<pre class="r"><code>## Tune over randomly sampled grid points
fit(surv_fo, data = surv_train,
    model = TunedModel(
      GBMModel,
      grid = Grid(size = 100, random = 10),
      control = surv_means_control
    ))

## Tune over user-specified grid points
fit(surv_fo, data = surv_train,
    model = TunedModel(
      GBMModel,
      grid = expand_params(n.trees = c(25, 50, 100),
                           interaction.depth = 1:3),
      control = surv_means_control
    ))</code></pre>
<p>Statistics summarizing the resampled performance metrics across all tuning parameter combinations can be obtained with the <code>summary()</code> function.</p>
<pre class="r"><code>summary(trained_model)
#&gt; $TrainStep1
#&gt; , , Metric = CIndex
#&gt; 
#&gt;             Statistic
#&gt; Model             Mean    Median         SD       Min       Max NA
#&gt;   GBMModel.1 0.7730294 0.7692308 0.07206580 0.6363636 0.9354839  0
#&gt;   GBMModel.2 0.7610614 0.7663043 0.06966664 0.6256684 0.8924731  0
#&gt;   GBMModel.3 0.7564966 0.7647059 0.06743686 0.6480447 0.8870968  0
#&gt;   GBMModel.4 0.7687377 0.7616580 0.08218605 0.6256983 0.9301075  0
#&gt;   GBMModel.5 0.7629211 0.7616580 0.07106607 0.6592179 0.9032258  0
#&gt;   GBMModel.6 0.7562730 0.7409326 0.07500287 0.5865922 0.8602151  0
#&gt;   GBMModel.7 0.7608822 0.7487685 0.07981747 0.5989305 0.8978495  0
#&gt;   GBMModel.8 0.7514888 0.7700535 0.06886940 0.6201117 0.8494624  0
#&gt;   GBMModel.9 0.7443015 0.7564767 0.06410204 0.6312849 0.8324324  0
#&gt; 
#&gt; , , Metric = RMSE
#&gt; 
#&gt;             Statistic
#&gt; Model             Mean   Median       SD      Min       Max NA
#&gt;   GBMModel.1  3818.182 3835.515 1251.954 1992.999  5953.100  0
#&gt;   GBMModel.2  4016.418 3642.123 1586.513 1792.675  8511.133  0
#&gt;   GBMModel.3  4226.311 3790.948 1873.500 1342.394  8857.896  0
#&gt;   GBMModel.4  5614.160 4428.054 3009.006 1912.743 11666.415  0
#&gt;   GBMModel.5  5407.976 3893.101 3288.373 1419.643 14090.833  0
#&gt;   GBMModel.6  5450.541 5941.670 2733.285 1535.649 10480.901  0
#&gt;   GBMModel.7  7922.834 6177.645 4506.633 2941.312 16243.705  0
#&gt;   GBMModel.8 10728.876 7384.484 7889.461 2564.302 26325.938  0
#&gt;   GBMModel.9 11470.890 9691.195 7191.709 1999.900 26402.048  0</code></pre>
<p>Line plots of tuning results display the resampled metric means, or another statistic specified with the <code>stat</code> argument, versus the first tuning parameter values and with lines grouped according to the remaining parameters, if any.</p>
<pre class="r"><code>plot(trained_model, type = &quot;line&quot;)
#&gt; $TrainStep1</code></pre>
<p><img src="img/using_strategies_tune_plot-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="model-selection" class="section level3">
<h3>Model Selection</h3>
<p>Model selection can be conducted by calling <code>fit()</code> with a <code>SelectedModel</code> to automatically choose from any combination of models and model parameters. Selection has as a special case the just-discussed tuning of a single model over a grid of parameter values. Combinations of model functions, function names, or function calls can be supplied to <code>SelectedModel()</code> in order to define sets of candidate models from which to select. An <code>expand_model()</code> helper function is additionally available to expand a model over a grid of tuning parameters for inclusion in the candidate set if so desired.</p>
<pre class="r"><code>## Model interface for model selection
sel_model &lt;- SelectedModel(
  expand_model(GBMModel, n.trees = c(50, 100), interaction.depth = 1:2),
  GLMNetModel(lambda = 0.01),
  CoxModel,
  SurvRegModel
)

## Fit the selected model
fit(surv_fo, data = surv_train, model = sel_model)</code></pre>
<p>Selection may also be performed over candidate sets that include tuned models. For instance, the <code>SelectedModel()</code> function is applicable to sets containing different classes of models each individually tuned over a grid of parameters.</p>
<pre class="r"><code>## Model interface for selection among tuned models
sel_tun_model &lt;- SelectedModel(
  TunedModel(GBMModel, control = surv_means_control),
  TunedModel(GLMNetModel, control = surv_means_control),
  TunedModel(CoxModel, control = surv_means_control)
)

## Fit the selected tuned model
fit(surv_fo, data = surv_train, model = sel_tun_model)</code></pre>
</div>
</div>
<div id="ensemble-learning" class="section level2">
<h2>Ensemble Learning</h2>
<p>Ensemble learning models combine <span class="math inline">\(m = 1, \ldots, M\)</span> base models as a strategy to improve predictive performance. Two methods implemented in <strong>MachineShop</strong> are <em>stacked regression</em> <span class="citation">(Breiman 1996)</span> and <em>super learners</em> <span class="citation">(van der Laan, Polley, and Hubbard 2007)</span>. Stacked regression fits a linear combination of predictions from specified base learners to produce a prediction function of the form <span class="math display">\[
\hat{f}(x) = \sum_{m=1}^M \hat{w}_m \hat{f}_m(x).
\]</span> Stacking weights <span class="math inline">\(w\)</span> are estimated by (constrained) least squares regression of case responses <span class="math inline">\(y_i\)</span> on predictions <span class="math inline">\(\hat{f}^{-\kappa(i)}(x_i)\)</span> from learners fit to data subsamples <span class="math inline">\(-\kappa(i)\)</span> not containing the corresponding cases. In particular, they are obtained as the solution <span class="math display">\[
\hat{w} = \underset{w}{\operatorname{argmin}} \sum_{i=1}^{N}\left(y_i - \sum_{m=1}^{M} w_m \hat{f}^{-\kappa(i)}(x_i) \right)^2
\]</span> subject to the constraints that all <span class="math inline">\(w_m \ge 0\)</span> and <span class="math inline">\(\sum_m w_m = 1\)</span>. K-fold cross-validation is the default subsampling method employed in the estimation, with the other resampling methods provided by the package available as options. Survival outcomes are handled with a modified version of the stacked regression algorithm in which</p>
<ul>
<li>minimization of least squares is replaced by maximization of Harrell’s concordance index <span class="citation">(1982)</span> to accommodate censoring, and</li>
<li>prediction can only be performed on the same response type used for the model fit; i.e., either survival means or survival probabilities at given follow-up times.</li>
</ul>
<p>Super learners are a generalization of stacked regression that fit a specified model, such as <code>GBMModel</code>, to case responses <span class="math inline">\(y_i\)</span>, base learner predictions <span class="math inline">\(\hat{f}^{-\kappa(i)}(x_i)\)</span>, and optionally also to the original predictor variables <span class="math inline">\(x_i\)</span>. Given below are examples of a stacked regression and super learner each fit with gradient boosted, random forest, and Cox regression base learners. A separate gradient boosted model is used as the super learner in the latter.</p>
<pre class="r"><code>## Stacked regression
stackedmodel &lt;- StackedModel(GLMBoostModel, CForestModel, CoxModel)
res_stacked &lt;- resample(surv_fo, data = surv_train, model = stackedmodel)
summary(res_stacked)
#&gt;          Statistic
#&gt; Metric         Mean    Median        SD Min    Max NA
#&gt;   C-Index 0.7560737 0.7467949 0.1341055 0.5 0.9375  0

## Super learner
supermodel &lt;- SuperModel(GLMBoostModel, CForestModel, CoxModel,
                         model = GBMModel)
res_super &lt;- resample(surv_fo, data = surv_train, model = supermodel)
summary(res_super)
#&gt;          Statistic
#&gt; Metric         Mean    Median         SD  Min       Max NA
#&gt;   C-Index 0.7146186 0.7440476 0.09896758 0.52 0.8536585  0</code></pre>
</div>
<div id="methodology" class="section level2">
<h2>Methodology</h2>
<p>Combinations and multiple levels of nested meta-functions, inputs, and models are allowed. If model fitting involves a single meta-function, performances of the inputs or models under consideration are estimated with standard resampling, and the best performing model is returned. Nestings of meta-functions are trained with nested resampling. Consider the example below in which training involves input tuning and model selection. In particular, a preprocessing recipe is tuned over the number of predictor-derived principal components and model selection is of an untuned <code>GBMModel</code>, a tuned <code>GBMModel</code>, and a <code>SuperModel</code>.</p>
<pre class="r"><code>## Preprocessing recipe with PCA steps
pca_rec &lt;- recipe(time + status ~ ., data = surv_train) %&gt;%
  role_surv(time = time, event = status) %&gt;%
  step_center(all_predictors()) %&gt;%
  step_scale(all_predictors()) %&gt;%
  step_pca(all_predictors(), id = &quot;PCA&quot;)

## Tuning grid of number of PCA components
pca_grid &lt;- expand_steps(
  PCA = list(num_comp = 1:3)
)

## Input specification
tun_rec &lt;- TunedInput(pca_rec, grid = pca_grid)

## Model specification
sel_model &lt;- SelectedModel(
  GBMModel,
  TunedModel(GBMModel),
  SuperModel(CoxModel, TunedModel(CForestModel), TunedModel(GLMBoostModel))
)

## Model fit and final trained model
model_fit &lt;- fit(tun_rec, model = sel_model)
as.MLModel(model_fit)</code></pre>
<p>Model fitting proceeds with instances of the specified model selection nested within each of the input tuning grid parameter values. Tuning of <code>GBMModel</code> and construction of <code>SuperModel</code> are further nested within the model selection, with tuning of <code>CForestModel</code> and <code>GLMBoostModel</code> nested within <code>SuperModel</code>. Altogether, there are four levels of meta-input and meta-model functions in the hierarchy.</p>
<p><img src="img/FigModelDAG.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Each meta-function is fit based on resample estimation (default: cross-validation) of predictive performance. When one meta-function is nested within another, nested resampling is employed, as illustrated in the figure below.</p>
<p><img src="img/FigNestedCV.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Nesting of resampling routines is repeated recursively when a fit involves multiple levels of nested meta-functions. For example, predictive performance estimation for the training of <code>TunedInput(pca_rec, grid = pca_grid)</code> involves up to three nested meta functions: <code>SelectedModel(...)</code> → <code>SuperModel(...)</code> → <code>TunedModel(CForestModel)</code>. For this relationship, an outer and three nested inner resampling loops are executed as follows. First, <code>CForestModel</code> is tuned at the third inner resampling loop. Second, the tuned model is passed to the second inner loop for construction of <code>SuperModel</code>. Third, the constructed model is passed to the first inner loop for model selection from the candidate set. Finally, the selected model is passed to the outer loop for tuning of the preprocessing recipe. Based on resample performance estimation of the entire input/model specification, one principal component is selected.</p>
<pre><code>#&gt; TrainStep1 :
#&gt; Object of class &quot;TrainBit&quot;
#&gt; 
#&gt; Grid (selected = 1):
#&gt; # A tibble: 3 x 1
#&gt;   ModelRecipe$PCA$num_comp
#&gt;                      &lt;int&gt;
#&gt; 1                        1
#&gt; 2                        2
#&gt; 3                        3
#&gt; 
#&gt; Object of class &quot;Performance&quot;
#&gt; 
#&gt; Metrics: C-Index 
#&gt; Models: 1, 2, 3 
#&gt; 
#&gt; Selected model: 1 
#&gt; C-Index value: 0.7806223</code></pre>
<p>In order to identify and return a final model fitted to the entire input data, the hierarchy is traversed from top to bottom along the path determined by the choice at each node. Steps along the path are labelled <code>TrainStep1</code>, <code>TrainStep2</code>, and <code>TrainStep3</code> in the output. As seen above in <code>TrainStep1</code>, one principal component is first selected for the tuned input. Using an input recipe with one principal component, the entire dataset is refit at <code>TrainStep2</code> to select <code>TunedModel(GBMModel)</code>.</p>
<pre><code>#&gt; TrainStep2 :
#&gt; Object of class &quot;TrainBit&quot;
#&gt; 
#&gt; Grid (selected = 2):
#&gt; # A tibble: 3 x 1
#&gt;   Model
#&gt;   &lt;fct&gt;
#&gt; 1 1    
#&gt; 2 2    
#&gt; 3 3    
#&gt; 
#&gt; Object of class &quot;Performance&quot;
#&gt; 
#&gt; Metrics: C-Index 
#&gt; Models: GBMModel, TunedModel, SuperModel 
#&gt; 
#&gt; Selected model: TunedModel 
#&gt; C-Index value: 0.7533878</code></pre>
<p>Finally, the entire dataset is refit in <code>TrainStep3</code> to select 50 trees and an interaction depth of 1 in the tuning of <code>GBMModel</code>.</p>
<pre><code>#&gt; TrainStep3 :
#&gt; Object of class &quot;TrainBit&quot;
#&gt; 
#&gt; Grid (selected = 1):
#&gt; # A tibble: 9 x 1
#&gt;   Model$n.trees $interaction.depth
#&gt;           &lt;dbl&gt;              &lt;int&gt;
#&gt; 1            50                  1
#&gt; 2           100                  1
#&gt; 3           150                  1
#&gt; 4            50                  2
#&gt; 5           100                  2
#&gt; 6           150                  2
#&gt; 7            50                  3
#&gt; 8           100                  3
#&gt; 9           150                  3
#&gt; 
#&gt; Object of class &quot;Performance&quot;
#&gt; 
#&gt; Metrics: C-Index 
#&gt; Models: GBMModel.1, GBMModel.2, GBMModel.3, GBMModel.4, GBMModel.5, GBMModel.6,
#&gt;   GBMModel.7, GBMModel.8, GBMModel.9 
#&gt; 
#&gt; Selected model: GBMModel.1 
#&gt; C-Index value: 0.7137925</code></pre>
<p>After the series of training steps reaches the bottom of its hierarchy, the final model is fitted to the entire dataset and returned.</p>
<pre><code>#&gt; Object of class &quot;MLModel&quot;
#&gt; 
#&gt; Model name: GBMModel
#&gt; Label: Trained Generalized Boosted Regression
#&gt; Package: gbm
#&gt; Response types: factor, numeric, PoissonVariate, Surv
#&gt; Tuning grid: TRUE
#&gt; Variable importance: TRUE
#&gt; 
#&gt; Parameters:
#&gt; List of 5
#&gt;  $ n.trees          : num 50
#&gt;  $ interaction.depth: int 1
#&gt;  $ n.minobsinnode   : num 10
#&gt;  $ shrinkage        : num 0.1
#&gt;  $ bag.fraction     : num 0.5</code></pre>
<p>Generalization performance of the entire process can be estimated with a call to <code>resample()</code>.</p>
<pre class="r"><code>## Generalization performance of the modeling strategy
resample(tun_rec, model = sel_model)</code></pre>
<p>There is no conceptual limit to the number of nested inputs and models that can be specified with the package. However, there are some practical issues to consider.</p>
<dl>
<dt>Computational Expense</dt>
<dd>Computational expense of nested resampling increases exponentially. For instance, execution of <em>r</em> levels of a nested 10-fold cross-validation algorithm is an O(10<sup><em>r</em></sup>) operation. Runtimes can be decreased by registering multiple cores to run the resampling algorithms in parallel. However, the exponential increase in computational complexity quickly outpaces the number of available cores.
</dd>
<dt>Data Reduction</dt>
<dd>Training data is reduced at each subsequent resampling level. For 10-fold cross-validation and a training set of <em>N</em> total cases, there will be 0.9<sup><em>r</em></sup> cases available at each fold of the <em>r</em><sup>th</sup> resampling algorithm. Bootstrapping could be used, as an alternative to cross-validation, to ensure <em>N</em> cases at each resampling level. However, the number of unique cases at level <em>r</em> will be decreased to approximately <em>N</em>(2/3)<sup><em>r</em></sup>.
</dd>
</dl>
</div>
</div>
<div id="global-settings" class="section level1">
<h1>Global Settings</h1>
<p>Core default behaviors of functions in the package can be viewed or changed globally through the <code>settings()</code> function. The function accepts one or more character names of settings to view, <code>name = value</code> pairs giving the values of settings to change, or a vector of these, with available settings summarized below.</p>
<dl>
<dt><code>control</code></dt>
<dd>function, function name, or call defining a default resampling method [default: <code>"CVControl"</code>].
</dd>
<dt><code>cutoff</code></dt>
<dd>numeric (0, 1) threshold above which binary factor probabilities are classified as events and below which survival probabilities are classified [default: 0.5].
</dd>
<dt><code>dist.Surv</code></dt>
<dd>character string specifying distributional approximations to estimated survival curves for predicting survival means. Choices are <code>"empirical"</code> for the Kaplan-Meier estimator, <code>"exponential"</code>, or <code>"weibull"</code> (default).
</dd>
<dt><code>dist.SurvProbs</code></dt>
<dd>character string specifying distributional approximations to estimated survival curves for predicting survival events/probabilities. Choices are <code>"empirical"</code> (default) for the Kaplan-Meier estimator, <code>"exponential"</code>, or <code>"weibull"</code>.
</dd>
<dt><code>grid</code></dt>
<dd><code>size</code> argument to <code>Grid()</code> indicating the number of parameter-specific values to generate automatically for tuning of models that have pre-defined grids or a <code>Grid()</code> function, function name, or call [default: 3].
</dd>
<dt><code>max.print</code></dt>
<dd>number of models or data rows to show with print methods or <code>Inf</code> to show all [default: 10].
</dd>
<dt><code>method.EmpiricalSurv</code></dt>
<dd>character string specifying the empirical method of estimating baseline survival curves for Cox proportional hazards-based models. Choices are <code>"breslow"</code>, <code>"efron"</code> (default), or <code>"fleming-harrington"</code>.
</dd>
<dt><code>metrics.ConfusionMatrix</code></dt>
<dd>function, function name, or vector of these with which to calculate performance metrics for confusion matrices [default: <code>c(Accuracy = "accuracy", Kappa = "kappa2", `Weighted Kappa` = "weighted_kappa2", Sensitivity = "sensitivity", Specificity = "specificity")</code>].
</dd>
<dt><code>metrics.factor</code></dt>
<dd>function, function name, or vector of these with which to calculate performance metrics for factor responses [default: <code>c(Brier = "brier", Accuracy = "accuracy", Kappa = "kappa2", `Weighted Kappa` = "weighted_kappa2", `ROC AUC` = "roc_auc", Sensitivity = "sensitivity", Specificity = "specificity")</code>].
</dd>
<dt><code>metrics.matrix</code></dt>
<dd>function, function name, or vector of these with which to calculate performance metrics for matrix responses [default: <code>c(RMSE = "rmse", R2 = "r2", MAE = "mae")</code>].
</dd>
<dt><code>metrics.numeric</code></dt>
<dd>function, function name, or vector of these with which to calculate performance metrics for numeric responses [default: <code>c(RMSE = "rmse", R2 = "r2", MAE = "mae")</code>].
</dd>
<dt><code>metrics.Surv</code></dt>
<dd>function, function name, or vector of these with which to calculate performance metrics for survival responses [default: <code>c(`C-Index` = "cindex", Brier = "brier", `ROC AUC` = "roc_auc", Accuracy = "accuracy")</code>].
</dd>
<dt><code>progress.resample</code></dt>
<dd>logical indicating whether to display a progress bar during resampling [default: <code>TRUE</code>]. Displayed only if a computing cluster is not registered or is registered with the <strong>doSNOW</strong> package.
</dd>
<dt><code>require</code></dt>
<dd>names of installed packages to load during parallel execution of resampling algorithms [default: <code>c("MachineShop", "survival", "recipes")</code>].
</dd>
<dt><code>reset</code></dt>
<dd>character names of settings to reset to their default values.
</dd>
<dt><code>RHS.formula</code></dt>
<dd>non-modifiable character vector of operators and functions allowed in traditional formula specifications.
</dd>
<dt><code>stat.Curve</code></dt>
<dd>function or character string naming a function to compute one summary statistic at each cutoff value of resampled metrics in performance curves, or <code>NULL</code> for resample-specific metrics [default: <code>"base::mean"</code>].
</dd>
<dt><code>stat.Resamples</code></dt>
<dd>function or character string naming a function to compute one summary statistic to control the ordering of models in plots [default: <code>"base::mean"</code>].
</dd>
<dt><code>stat.train</code></dt>
<dd>function or character string naming a function to compute one summary statistic on resampled performance metrics for input selection or tuning or for model selection or tuning [default: <code>"base::mean"</code>].
</dd>
<dt><code>stats.PartialDependence</code></dt>
<dd>function, function name, or vector of these with which to compute partial dependence summary statistics [default: <code>c(Mean = "base::mean")</code>].
</dd>
<dt><code>stats.Resamples</code></dt>
<dd>function, function name, or vector of these with which to compute summary statistics on resampled performance metrics [default: <code>c(Mean = "base::mean", Median = "stats::median", SD = "stats::sd", Min = "base::min", Max = "base::max")</code>].
</dd>
<dt><code>verbose.resample</code></dt>
<dd>logical indicating whether to enable verbose messages when resampling [default: <code>FALSE</code>].
</dd>
</dl>
<p>A call to <code>settings()</code> with <code>"reset"</code> will restore all package defaults and with no arguments will display the current values of all. Settings may also be supplied as a single unnamed argument which is a named list. Partial matching of setting names is supported. The setting value is returned if only one is specified to view. Otherwise, a list is returned with the values of specified settings as they existed prior to any requested changes. Such a list can be passed as an argument to <code>settings()</code> to restore their values.</p>
<pre class="r"><code>## Change settings
presets &lt;- settings(control = &quot;BootControl&quot;, grid = 10)

## View one setting
settings(&quot;control&quot;)
#&gt; [1] &quot;BootControl&quot;

## View multiple settings
settings(&quot;control&quot;, &quot;grid&quot;)
#&gt; $control
#&gt; [1] &quot;BootControl&quot;
#&gt; 
#&gt; $grid
#&gt; Object of class &quot;Grid&quot;
#&gt; 
#&gt; Size: 10
#&gt; Random sample: FALSE

## Restore the previous settings
settings(presets)</code></pre>
</div>
<div id="package-extensions" class="section level1">
<h1>Package Extensions</h1>
<p>Custom models and metrics can be defined with <code>MLModel()</code> and <code>MLMetric()</code> for use with the model fitting, prediction, and performance assessment tools provided by the package.</p>
<div id="custom-models" class="section level2">
<h2>Custom Models</h2>
<p>The <code>MLModel()</code> function creates a model object that can be used with the previously described fitting functions. It take the following arguments.</p>
<dl>
<dt><code>name</code></dt>
<dd>Character name of the object to which the model is assigned.
</dd>
<dt><code>label</code></dt>
<dd>Optional character descriptor for the model (default: <code>name</code>).
</dd>
<dt><code>packages</code></dt>
<dd>Character vector of source packages required to use the model.
</dd>
<dt><code>response_types</code></dt>
<dd>Character vector of response variable types to which the model can be fit. Supported types are <code>"binary"</code>, <code>"factor"</code>, <code>"matrix"</code>, <code>"numeric"</code>, <code>"ordered"</code>, and <code>"Surv"</code>.
</dd>
<dt><code>fit</code></dt>
<dd>Model fitting function whose arguments are a <code>formula</code>, a <code>ModelFrame</code> named <code>data</code>, case <code>weights</code>, and an ellipsis. Argument <code>data</code> may be converted to a data frame with the <code>as.data.frame()</code> function as commonly needed. The fit function should return the object resulting from the model fit.
</dd>
<dt><code>predict</code></dt>
<dd>Prediction function whose arguments are the <code>object</code> returned by <code>fit()</code>, a <code>ModelFrame</code> named <code>newdata</code> of predictor variables, optional vector of <code>times</code> at which to predict survival, and an ellipsis. Argument <code>data</code> may be converted to a data frame with the <code>as.data.frame()</code> function as needed. Values returned by the function should be formatted according to the response variable types below.
</dd>
</dl>
<ul>
<li><code>factor</code> : Vector or column matrix of probabilities for the second level of binary factors or a matrix whose columns contain the probabilities for factors with more than two levels.</li>
<li><code>matrix</code> : Matrix of predicted responses.</li>
<li><code>numeric</code> : Vector or column matrix of predicted responses.</li>
<li><code>Surv</code> : Matrix whose columns contain survival probabilities at <code>times</code> if supplied or a vector of predicted survival means otherwise.</li>
</ul>
<dl>
<dt><code>varimp</code></dt>
<dd>Variable importance function whose arguments are the <code>object</code> returned by <code>fit()</code>, optional arguments passed from calls to <code>varimp()</code>, and an ellipsis. The function should return a vector of importance values named after the predictor variables or a matrix or data frame whose rows are named after the predictors.
</dd>
</dl>
<pre class="r"><code>## Logistic regression model extension
LogisticModel &lt;- MLModel(
  name = &quot;LogisticModel&quot;,
  label = &quot;Logistic Model&quot;,
  response_types = &quot;binary&quot;,
  fit = function(formula, data, weights, ...) {
    glm(formula, data = as.data.frame(data), weights = weights,
        family = binomial, ...)
  },
  predict = function(object, newdata, ...) {
    predict(object, newdata = as.data.frame(newdata), type = &quot;response&quot;)
  },
  varimp = function(object, ...) {
    pchisq(coef(object)^2 / diag(vcov(object)), 1)
  }
)</code></pre>
</div>
<div id="custom-metrics" class="section level2">
<h2>Custom Metrics</h2>
<p>The <code>MLMetric()</code> function creates a metric object that can be used as previously described for the model performance metrics. Its first argument is a function to compute the metric, defined to accept <code>observed</code> and <code>predicted</code> as the first two arguments and with an ellipsis to accommodate others. Its remaining arguments are as follows.</p>
<dl>
<dt><code>name</code></dt>
<dd>Character name of the object to which the metric is assigned.
</dd>
<dt><code>label</code></dt>
<dd>Optional character descriptor for the metric (default: <code>name</code>).
</dd>
<dt><code>maximize</code></dt>
<dd>Logical indicating whether higher values of the metric correspond to better predictive performance.
</dd>
</dl>
<pre class="r"><code>## F2 score metric extension
f2_score &lt;- MLMetric(
  function(observed, predicted, ...) {
    f_score(observed, predicted, beta = 2, ...)
  },
  name = &quot;f2_score&quot;,
  label = &quot;F2 Score&quot;,
  maximize = TRUE
)</code></pre>
</div>
<div id="usage" class="section level2">
<h2>Usage</h2>
<p>Once created, model and metric extensions can be used with the package-supplied fitting and performance functions.</p>
<pre class="r"><code>## Logistic regression analysis
data(Pima.tr, package = &quot;MASS&quot;)
res &lt;- resample(type ~ ., data = Pima.tr, model = LogisticModel)
summary(performance(res, metric = f2_score))
#&gt;           Statistic
#&gt; Metric          Mean    Median        SD       Min       Max NA
#&gt;   f2_score 0.6090287 0.6155303 0.1707673 0.3030303 0.8571429  0</code></pre>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-andersen:1993:SMB" class="csl-entry">
Andersen, Per K, Ornulf Borgan, Richard D Gill, and Niels Keiding. 1993. <em>Statistical Models Based on Counting Processes</em>. New York: Springer.
</div>
<div id="ref-bache:2014:MFP" class="csl-entry">
Bache, Stefan Milton, and Hadley Wickham. 2014. <em><span class="nocase">magrittr</span>: A Forward-Pipe Operator for r</em>. <a href="https://CRAN.R-project.org/package=magrittr">https://CRAN.R-project.org/package=magrittr</a>.
</div>
<div id="ref-breiman:1996:SR" class="csl-entry">
Breiman, Leo. 1996. <span>“Stacked Regression.”</span> <em>Machine Learning</em> 24: 49–64.
</div>
<div id="ref-breslow:1972:DPC" class="csl-entry">
Breslow, Norman E. 1972. <span>“Discussion of <span class="nocase">Professor Cox’s</span> Paper.”</span> <em>Journal of the Royal Statistical Society, Series B</em> 34: 216–17.
</div>
<div id="ref-davis:2006:RPR" class="csl-entry">
Davis, Jesse, and Mark Goadrich. 2006. <span>“The Relationship Between Precision-Recall and <span>ROC</span> Curves.”</span> In <em>Proceedings of the 23rd International Conference on Machine Learning</em>, 233–40. ICML ’06. New York, NY, USA: ACM.
</div>
<div id="ref-davison:1997:BMA" class="csl-entry">
Davison, Anthony C, and David V Hinkley. 1997. <em>Bootstrap Methods and Their Application</em>. New York, NY, USA: Cambridge University Press.
</div>
<div id="ref-efron:1967:PFB" class="csl-entry">
Efron, Bradley. 1967. <span>“The Two Sample Problem with Censored Data.”</span> In <em>Proceedings of the Fifth Berkeley Symposium on Mathematical Statistics and Probability, Volume 4: Biology and Problems of Health</em>, 831–53. Berkeley, California: University of California Press.
</div>
<div id="ref-efron:1977:ECL" class="csl-entry">
———. 1977. <span>“The Efficiency of <span class="nocase">Cox’s</span> Likelihood Function for Censored Data.”</span> <em>Journal of the American Statistical Association</em> 72 (359): 557–65.
</div>
<div id="ref-efron:1986:HBA" class="csl-entry">
———. 1986. <span>“How Biased Is the Apparent Error Rate of a Prediction Rule?”</span> <em>Journal of the American Statistical Association</em> 81 (394): 461–70.
</div>
<div id="ref-efron:1983:LLB" class="csl-entry">
Efron, Bradley, and Gail Gong. 1983. <span>“A Leisurely Look at the Bootstrap, the Jackknife, and Cross-Validation.”</span> <em>The American Statistician</em> 37 (1): 36–48.
</div>
<div id="ref-efron:1993:IB" class="csl-entry">
Efron, Bradley, and Robert J Tibshirani. 1993. <em>An Introduction to the Bootstrap</em>. Monographs on Statistics and Applied Probability 57. Boca Raton, Florida, USA: Chapman &amp; Hall/CRC.
</div>
<div id="ref-fawcett:2006:IRA" class="csl-entry">
Fawcett, Tom. 2006. <span>“An Introduction to <span>ROC</span> Analysis.”</span> <em>Pattern Recognition Letters</em> 27 (8): 861–74.
</div>
<div id="ref-fleming:1984:NES" class="csl-entry">
Fleming, Thomas R, and David P Harrington. 1984. <span>“Nonparametric Estimation of the Survival Distribution in Censored Data.”</span> <em>Communications in Statistics - Theory and Methods</em> 13 (20): 2469–86.
</div>
<div id="ref-graf:1999:ACP" class="csl-entry">
Graf, Erika, Claudia Schmoor, Willi Sauerbrei, and Martin Schumacher. 1999. <span>“Assessment and Comparison of Prognostic Classification Schemes for Survival Data.”</span> <em>Statistics in Medicine</em> 18 (17–18): 2529–45.
</div>
<div id="ref-greenwell:2019:GBM" class="csl-entry">
Greenwell, Brandon, Bradley Boehmke, Jay Cunningham, and GBM Developers. 2019. <em><span class="nocase">gbm</span>: Generalized Boosted Regression Models</em>. <a href="https://CRAN.R-project.org/package=gbm">https://CRAN.R-project.org/package=gbm</a>.
</div>
<div id="ref-harrell:1982:EYM" class="csl-entry">
Harrell, Frank E, Robert M Califf, David B Pryor, Kerry L Lee, and Robert A Rosati. 1982. <span>“Evaluating the Yield of Medical Tests.”</span> <em>JAMA</em> 247 (18): 2543–46.
</div>
<div id="ref-harrell:1996:MPM" class="csl-entry">
Harrell, Frank E, Kerry L Lee, and Daniel B Mark. 1996. <span>“Multivariable Prognostic Models: Issues in Developing Models, Evaluating Assumptions and Adequacy, and Measuring and Reducing Errors.”</span> <em>Statistics in Medicine</em> 15 (4): 361–87.
</div>
<div id="ref-hastie:2009:ESL7" class="csl-entry">
Hastie, Trevor, Robert Tibshirani, and Jerome Friedman. 2009. <span>“The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition.”</span> In. Springer Series in Statistics. New York, NY, USA: Springer.
</div>
<div id="ref-heagerty:2004:TDR" class="csl-entry">
Heagerty, Patrick J, Thomas Lumley, and Margaret S Pepe. 2004. <span>“Time-Dependent <span>ROC</span> Curves for Censored Survival Data and a Diagnostic Marker.”</span> <em>Biometrics</em> 56 (2): 337–44.
</div>
<div id="ref-kohavi:1995:SCB" class="csl-entry">
Kohavi, Ron. 1995. <span>“A Study of Cross-Validation and Bootstrap for Accuracy Estimation and Model Selection.”</span> In <em>Proceedings of the 14th International Joint Conference on Artificial Intelligence - Volume 2</em>, 1137–43. IJCAI’95. San Francisco, CA, USA: Morgan Kaufmann Publishers Inc.
</div>
<div id="ref-kuhn:2020:RPT" class="csl-entry">
Kuhn, Max, and Hadley Wickham. 2020. <em><span class="nocase">recipes</span>: Preprocessing Tools to Create Design Matrices</em>. <a href="https://CRAN.R-project.org/package=recipes">https://CRAN.R-project.org/package=recipes</a>.
</div>
<div id="ref-microsoft:2019:DFS" class="csl-entry">
Microsoft Corporation, and Stephen Weston. 2019a. <em><span class="nocase">doSNOW</span>: Foreach Parallel Adaptor for the ’Snow’ Package</em>. <a href="https://CRAN.R-project.org/package=doSNOW">https://CRAN.R-project.org/package=doSNOW</a>.
</div>
<div id="ref-microsoft:2019:DFP" class="csl-entry">
Microsoft Corporation, and Steve Weston. 2019b. <em><span class="nocase">doParallel</span>: Foreach Parallel Adaptor for the ’Parallel’ Package</em>. <a href="https://CRAN.R-project.org/package=doParallel">https://CRAN.R-project.org/package=doParallel</a>.
</div>
<div id="ref-microsoft:2019:FPF" class="csl-entry">
Microsoft, and Steve Weston. 2019. <em><span class="nocase">foreach</span>: Provides Foreach Looping Construct for r</em>. <a href="https://CRAN.R-project.org/package=foreach">https://CRAN.R-project.org/package=foreach</a>.
</div>
<div id="ref-perkins:2006:IOC" class="csl-entry">
Perkins, Neil J, and Enrique F Schisterman. 2006. <span>“The Inconsistency of "Optimal" Cutpoints Obtained Using Two Criteria Based on the Receiver Operating Characteristic Curve.”</span> <em>American Journal of Epidemiology</em> 163 (7): 670–75.
</div>
<div id="ref-therneau:2020:SA" class="csl-entry">
Therneau, Terry M. 2020. <em>A Package for Survival Analysis in r</em>. <a href="https://CRAN.R-project.org/package=survival">https://CRAN.R-project.org/package=survival</a>.
</div>
<div id="ref-vanderLaan:2007:SL" class="csl-entry">
van der Laan, Mark J, Eric C Polley, and Alan E Hubbard. 2007. <span>“Super Learner.”</span> <em>Statistical Applications in Genetics and Molecular Biology</em> 6 (1).
</div>
<div id="ref-wickham:2016:GEG" class="csl-entry">
Wickham, Hadley. 2016. <em><span class="nocase">ggplot2</span>: Elegant Graphics for Data Analysis</em>. Springer-Verlag New York. <a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>.
</div>
<div id="ref-youden:1950:IRD" class="csl-entry">
Youden, William J. 1950. <span>“Index for Rating Diagnostic Tests.”</span> <em>Cancer</em> 3 (1): 32–35.
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
